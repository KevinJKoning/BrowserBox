<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BrowserBox</title>
    <style>
        :root {
            --primary-bg: #ffffff;
            --panel-bg: #f9f9f9;
            --border-color: #e0e0e0;
            --accent-color: #3498db;
            --text-color: #333333;
            --secondary-text: #666666;
            --terminal-bg: #2d3436;
            --terminal-text: #ecf0f1;
            --drop-zone-hover: rgba(52, 152, 219, 0.1);
            --new-file-indicator-bg: #d1e7dd; /* Light green for new files */
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        }

        body {
            background-color: var(--primary-bg);
            color: var(--text-color);
            height: 100vh;
            padding: 20px;
            margin: 0;
            box-sizing: border-box;
        }

        .container {
            display: grid;
            grid-template-columns: 35% 65%; /* left side 35%, right side 65% */
            grid-template-rows: 1fr; /* single row */
            grid-template-areas:
                "left-column right-column";
            gap: 16px;
            height: calc(100vh - 40px);
            max-height: calc(100vh - 40px);
            width: calc(100vw - 40px);
            max-width: 1400px;
            margin: 0 auto;
            box-sizing: border-box;
        }

        .left-column {
            grid-area: left-column;
            display: grid;
            grid-template-columns: 1fr;
            grid-template-rows: 1fr 1fr 1fr; /* three equal sections */
            grid-template-areas:
                "file-drop-zone"
                "script-zone"
                "file-output-zone";
            gap: 16px;
            height: 100%;
            max-height: 100%;
            overflow: hidden;
        }

        .right-column {
            grid-area: right-column;
            display: grid;
            grid-template-columns: 1fr;
            grid-template-rows: 1fr 1fr 1fr; /* three equal sections to match left */
            grid-template-areas:
                "preview"
                "preview"
                "terminal";
            gap: 16px;
            height: 100%;
            max-height: 100%;
            min-height: 0;
            overflow: hidden;
        }

        .drop-zone {
            background-color: var(--panel-bg);
            border: 2px dashed #777777;
            border-radius: 8px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            transition: all 0.3s ease;
            overflow: hidden;
            height: 100%;
            max-height: 100%;
            min-height: 0;
        }
        
        .drop-zone .instructions, .output-panel .instructions {
            display: block;
            text-align: left;
            flex-shrink: 0;
            margin-bottom: 8px;
        }

        .drop-zone:hover {
            background-color: var(--drop-zone-hover);
        }

        .drop-zone.active {
            border-color: var(--accent-color);
            background-color: var(--drop-zone-hover);
        }

        .drop-zone p, .output-panel p {
            margin-bottom: 8px;
            font-weight: normal;
        }

        .file-tile {
            background-color: #e9ecef;
            border: 1px solid #ced4da;
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            font-size: 0.9rem;
            cursor: pointer;
        }

        .file-tile.selected {
            border: 3px solid #2980b9 !important;
        }

        .file-tile.hollow {
            background-color: #f8f9fa;
            border: 2px dashed #adb5bd;
            opacity: 0.7;
        }

        .file-tile.filled {
            background-color: #d1e7dd;
            border-color: #a3cfbb;
        }

        .file-tile.light-green {
            background-color: #e8f5e8;
            border-color: #c3e6c3;
        }
        
        .file-tile.success {
            background-color: #d1e7dd;
            border-color: #a3cfbb;
        }

        .file-tile .details {
            flex-grow: 1;
        }

        .file-tile .file-name {
            font-weight: 500;
            display: block;
            margin-bottom: 4px;
        }

        .file-tile .file-info {
            font-size: 0.8rem;
            color: var(--secondary-text);
        }

        .drop-all-tile {
            background-color: #fff3cd;
            border: 2px dashed #ffc107;
            border-radius: 4px;
            padding: 15px;
            margin-bottom: 8px;
            text-align: center;
            font-size: 0.9rem;
            cursor: pointer;
        }

        .drop-all-tile:hover {
            background-color: #ffecb5;
        }

        .sub-text {
            font-size: 0.8rem;
            color: var(--secondary-text);
        }

        .file-drop-zone {
            grid-area: file-drop-zone;
            max-height: 100%;
            overflow: hidden;
        }

        .script-zone {
            grid-area: script-zone;
            max-height: 100%;
            overflow: hidden;
        }

        .file-output-zone {
            grid-area: file-output-zone;
            max-height: 100%;
            overflow: hidden;
        }
        
        .output-panel {
            background-color: var(--panel-bg);
            border-radius: 8px;
            padding: 20px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            border: 2px solid #777777;
            height: 100%;
            max-height: 100%;
            min-height: 0;
        }

        .preview-panel {
            grid-area: preview;
            background-color: var(--panel-bg);
            border-radius: 8px;
            padding: 20px;
            overflow-y: auto;
            display: block;
            border: 2px solid #777777;
            height: 100%;
            max-height: 100%;
            min-height: 0;
            box-sizing: border-box;
        }

        .preview-panel .empty-state {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100%;
            color: var(--secondary-text);
        }

        .terminal {
            grid-area: terminal;
            background-color: var(--terminal-bg);
            border-radius: 8px;
            color: var(--terminal-text);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 100%;
            max-height: 100%;
        }

        .terminal-header {
            padding: 8px 16px;
            background-color: rgba(255, 255, 255, 0.05);
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .terminal-actions { /* New style for button group */
            display: flex;
            gap: 8px;
        }

        .terminal-header button {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            color: var(--terminal-text);
            padding: 2px 8px;
            cursor: pointer;
            font-size: 0.8rem;
        }

        .terminal-header button:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .terminal-content {
            padding: 16px;
            overflow-y: auto;
            flex-grow: 1;
            font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.4;
            white-space: pre-wrap;
        }

        .file-list {
            list-style: none;
            width: 100%;
            flex: 1;
            overflow-y: auto;
            min-height: 0;
        }

        .script-files-list {
            list-style: none;
            width: 100%;
            flex: 1;
            overflow-y: auto;
            min-height: 0;
        }

        .file-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
            font-size: 0.9rem;
        }

        .file-table th {
            text-align: left;
            padding: 6px 8px;
            border-bottom: 1px solid var(--border-color);
            font-weight: 500;
            color: var(--secondary-text);
        }
        
        /* Action buttons styling */
        .action-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-shrink: 0;
        }
        
        .btn {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .btn-run {
            background-color: var(--accent-color);
            color: white;
        }
        
        .btn-run:hover:not(:disabled) {
            background-color: #2980b9;
        }

        .btn-download {
            background-color: #27ae60;
            color: white;
        }
        
        .btn-download:hover:not(:disabled) {
            background-color: #219651;
        }
        
        .btn-include {
            background-color: #8e44ad;
            color: white;
        }
        
        .btn-include:hover:not(:disabled) {
            background-color: #7d3c98;
        }
        
        /* Badge for included files */
        .included-badge {
            display: inline-block;
            background-color: #8e44ad;
            color: white;
            font-size: 0.7rem;
            padding: 2px 6px;
            border-radius: 10px;
            margin-left: 6px;
            vertical-align: middle;
        }
        
        /* Sortable table headers */
        .sortable {
            cursor: pointer;
            position: relative;
            padding-right: 18px !important;
        }
        
        .sortable:after {
            content: "↑↓";
            font-size: 0.7em;
            position: absolute;
            right: 6px;
            opacity: 0.3;
        }
        
        .sortable.sort-active:after {
            opacity: 1;
        }
        
        .sortable.sort-asc:after {
            content: "↑";
        }
        
        .sortable.sort-desc:after {
            content: "↓";
        }

        .file-table td {
            padding: 8px;
            border-bottom: 1px solid var(--border-color);
        }

        .file-row {
            cursor: pointer;
            transition: background-color 0.5s ease-out; /* Added transition for smooth highlight fade */
        }

        .file-row:hover {
            background-color: rgba(0, 0, 0, 0.05);
        }

        .file-row.active {
            background-color: var(--accent-color);
            color: white;
        }
        
        .file-row.active td {
            border-bottom-color: var(--accent-color);
        }

        .file-row.new-file-indicator { /* New class for highlighting new files */
            background-color: var(--new-file-indicator-bg);
        }

        .file-icon {
            margin-right: 4px;
            font-size: 1.1rem;
        }
        
        .file-checkbox {
            cursor: pointer;
            width: 16px;
            height: 16px;
        }

        .file-preview {
            width: 100%;
            overflow: auto;
            text-align: left;
            max-height: calc(100% - 120px);
            box-sizing: border-box;
        }

        .code-preview {
            padding: 16px;
            font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.4;
            background-color: #f5f5f5;
            border-radius: 4px;
            white-space: pre;
            overflow: auto;
            max-height: calc(100% - 120px);
            box-sizing: border-box;
        }

        .run-button {
            background-color: var(--accent-color);
            color: white;
            border: none;
            border-radius: 4px;
            padding: 6px 12px;
            margin-top: 12px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background-color 0.2s;
        }

        .run-button:hover {
            background-color: #2980b9;
        }

        .run-button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }
        
        /* Parquet table styling */
        .parquet-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9rem;
        }
        
        .parquet-table th {
            background-color: #f5f5f5;
            padding: 8px 12px;
            text-align: left;
            font-weight: 600;
            border-bottom: 2px solid #ddd;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        
        .parquet-table td {
            padding: 8px 12px;
            border-bottom: 1px solid #eee;
            white-space: nowrap;
            max-width: 300px;
            overflow: hidden;
            text-overflow: ellipsis;
            height: 36px; /* Fixed height for table rows */
            line-height: 20px; /* Line height for better text display */
        }
        
        .parquet-table tr:hover td {
            background-color: rgba(0, 0, 0, 0.02);
        }
        
        /* Error message styling */
        .error {
            color: #e74c3c;
            padding: 12px;
            background-color: #fdf1f0;
            border-left: 4px solid #e74c3c;
            margin: 10px 0;
            border-radius: 0 4px 4px 0;
        }

        /* For responsiveness */
        @media (max-width: 768px) {
            .container {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto auto auto auto;
                grid-template-areas:
                    "file-drop-zone"
                    "script-zone"
                    "file-output-zone"
                    "preview"
                    "terminal";
                height: auto;
            }
            
            .left-column {
                display: contents;
            }
            
            .right-column {
                display: contents;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="left-column">
            <div class="drop-zone file-drop-zone" id="fileDropZone">
                <div id="fileDropZoneInstructions" class="instructions">
                    <p>Load scripts to see required files</p>
                    <p class="sub-text">If using magic comments (# user_files:), otherwise click or drag/drop data files here</p>
                </div>
                <div id="fileDropZoneList" class="file-list"></div>
            </div>
            
            <div class="drop-zone script-zone" id="scriptZone">
                <div id="scriptZoneInstructions" class="instructions">
                    <p>Click or drag/drop python scripts here</p>
                    <p class="sub-text">Use magic comments (# process_files:) to load other script output automatically</p>
                </div>
                <div id="scriptsList" class="script-files-list"></div>
            </div>
            
            <div class="output-panel file-output-zone" id="fileOutputZone">
                <div id="fileOutputInstructions" class="instructions">
                    <p>Output Files</p>
                    <p class="sub-text">Files generated by scripts appear here</p>
                </div>
                <div id="outputFilesList" class="file-list"></div>
            </div>
        </div>
        
        <div class="right-column">
            <div class="preview-panel" id="previewPanel">
                <div class="empty-state">Select a File to Preview</div>
            </div>
            
            <div class="terminal" id="terminal">
                <div class="terminal-header">
                    <span>Terminal Output</span>
                    <div class="terminal-actions">
                        <button id="copyTerminal">Copy</button>
                        <button id="clearTerminal">Clear</button>
                    </div>
                </div>
                <div class="terminal-content" id="terminalContent"></div>
            </div>
        </div>
    </div>

    <!-- Web Worker Blob URLs will be stored here -->
    <script id="webworker" type="text/worker-script">
        // This will be converted to a Blob URL and used to create the worker
        // webworker.js
        importScripts("https://cdn.jsdelivr.net/pyodide/v0.27.5/full/pyodide.js");

        let pyodide;
        
        async function loadPyodideAndPackages() {
            self.pyodide = await loadPyodide();
            return self.pyodide;
        }
        
        // Start loading pyodide when the worker starts
        let pyodideReadyPromise = loadPyodideAndPackages();

        self.onmessage = async function(event) {
            // Make sure pyodide is ready
            self.pyodide = await pyodideReadyPromise;
            
            const { id, python, context, files } = event.data;
            
            // Create a status update function to send progress back to main thread
            function sendStatus(status) {
                self.postMessage({ id, status });
            }
            
            try {
                sendStatus("Loading packages...");
                await self.pyodide.loadPackagesFromImports(python);
                
                // Create the data directory for files
                sendStatus("Setting up filesystem...");
                self.pyodide.runPython(`
                    import os
                    if not os.path.exists('/home/pyodide/data'):
                        os.makedirs('/home/pyodide/data')
                `);
                
                // Add any files to the virtual filesystem
                if (files && files.length > 0) {
                    sendStatus("Loading files into filesystem...");
                    
                    // Write each file to the virtual filesystem
                    for (const file of files) {
                        const path = `/home/pyodide/data/${file.name}`;
                        self.pyodide.FS.writeFile(path, new Uint8Array(file.data));
                    }
                }
                
                // Set up the context
                sendStatus("Preparing context...");
                const globals = self.pyodide.toPy(context || {});
                
                // Add utility functions to the context
                self.pyodide.runPython(`
                    import sys
                    import os
                    
                    # Set up data directory in path
                    data_dir = '/home/pyodide/data'
                    sys.path.append(data_dir)
                    
                    # Set current working directory to data directory
                    # This ensures all relative file operations happen in our data directory
                    os.chdir(data_dir)
                    
                    # Redirect stdout and stderr to capture output
                    import io
                    
                    class OutputCollector:
                        def __init__(self):
                            self.value = ""
                        
                        def write(self, text):
                            self.value += text
                            return len(text)
                        
                        def flush(self):
                            pass
                    
                    stdout_collector = OutputCollector()
                    stderr_collector = OutputCollector()
                    
                    old_stdout = sys.stdout
                    old_stderr = sys.stderr
                    
                    sys.stdout = stdout_collector
                    sys.stderr = stderr_collector
                `);
                
                // Run the Python code
                sendStatus("Running Python code...");
                const output = await self.pyodide.runPythonAsync(python, { globals });
                
                // Get captured stdout and stderr
                const stdout = self.pyodide.runPython("stdout_collector.value");
                const stderr = self.pyodide.runPython("stderr_collector.value");
                
                // Reset stdout and stderr
                self.pyodide.runPython(`
                    sys.stdout = old_stdout
                    sys.stderr = old_stderr
                `);
                
                // Collect all files from the virtual filesystem
                sendStatus("Collecting modified files...");
                const modifiedFiles = [];
                
                try {
                    // Make sure the data directory exists (it should, but double-check)
                    self.pyodide.runPython(`
                        import os
                        if not os.path.exists('/home/pyodide/data'):
                            os.makedirs('/home/pyodide/data')
                    `);
                    
                    // Get the list of files in the data directory
                    const dataFiles = self.pyodide.FS.readdir('/home/pyodide/data');
                    
                    // Filter out special entries . and ..
                    const regularFiles = dataFiles.filter(name => name !== '.' && name !== '..');
                    
                    sendStatus(`Found ${regularFiles.length} files to collect`);
                    
                    // Read each file and convert to transferable format
                    for (const fileName of regularFiles) {
                        try {
                            const path = `/home/pyodide/data/${fileName}`;
                            const content = self.pyodide.FS.readFile(path, { encoding: 'binary' });
                            
                            modifiedFiles.push({
                                name: fileName,
                                data: content
                            });
                            
                            sendStatus(`Collected file: ${fileName}`);
                        } catch (fileError) {
                            console.error(`Error reading file ${fileName}:`, fileError);
                            sendStatus(`Error collecting file: ${fileName}`);
                        }
                    }
                } catch (fsError) {
                    console.error("Error reading filesystem:", fsError);
                    sendStatus(`Error accessing filesystem: ${fsError.message}`);
                }
                
                // Send back results with modified files
                self.postMessage({
                    id,
                    status: "complete", 
                    result: output,
                    stdout,
                    stderr,
                    modifiedFiles: modifiedFiles
                });
                
            } catch (error) {
                // When there's an error, we should still try to get stderr if possible
                let stderr = "";
                try {
                    stderr = self.pyodide.runPython("stderr_collector.value");
                } catch (e) {
                    // If we can't get stderr from the collector, just use the error message
                    stderr = error.message || "Unknown error";
                }
                
                self.postMessage({
                    id, 
                    status: "error",
                    error: error.message,
                    stderr: stderr
                });
            }
        };
    </script>

    <script>
        // Store files
        const userFiles = []; // Files provided by user in file drop zone
        const processFiles = []; // Files created by script processes (output files)
        const pythonScripts = []; // For python scripts { name, content, userFiles: [], processFiles: [], fileObject, id }
        let selectedFile = null; // For preview
        let activeScript = null; // Currently selected script
        
        // Map of active workers, keyed by script name
        const activeWorkers = {};

        // DOM Elements
        const fileDropZone = document.getElementById('fileDropZone'); 
        const fileDropZoneList = document.getElementById('fileDropZoneList');
        const scriptZone = document.getElementById('scriptZone');
        const scriptsList = document.getElementById('scriptsList');
        const fileOutputZone = document.getElementById('fileOutputZone');
        const outputFilesList = document.getElementById('outputFilesList');
        const previewPanel = document.getElementById('previewPanel');
        const terminalContent = document.getElementById('terminalContent');
        const clearTerminalBtn = document.getElementById('clearTerminal');
        const copyTerminalBtn = document.getElementById('copyTerminal'); 

        // Create web worker from inline script
        function createWorker() {
            const workerScript = document.getElementById('webworker').textContent;
            const blob = new Blob([workerScript], { type: 'application/javascript' });
            const workerUrl = URL.createObjectURL(blob);
            return new Worker(workerUrl);
        }

        // Log to terminal
        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logElement = document.createElement('div');
            logElement.className = `log-entry ${type}`;
            logElement.innerHTML = `[${timestamp}] ${message}`;
            terminalContent.appendChild(logElement);
            terminalContent.scrollTop = terminalContent.scrollHeight;
            
            // Add styling for different log types if it doesn't exist
            if (!document.getElementById('log-styles')) {
                const styleEl = document.createElement('style');
                styleEl.id = 'log-styles';
                styleEl.textContent = `
                    .log-entry.error { color: #e74c3c; }
                    .log-entry.warning { color: #f39c12; }
                    .log-entry.success { color: #2ecc71; }
                `;
                document.head.appendChild(styleEl);
            }
        }

        // Clear terminal
        clearTerminalBtn.addEventListener('click', () => {
            terminalContent.innerHTML = '';
            log('Terminal cleared');
        });

        // Copy terminal content
        copyTerminalBtn.addEventListener('click', () => {
            const textToCopy = terminalContent.textContent;
            if (textToCopy) {
                navigator.clipboard.writeText(textToCopy)
                    .then(() => {
                        log('Terminal content copied to clipboard.', 'success');
                    })
                    .catch(err => {
                        log('Failed to copy terminal content: ' + err, 'error');
                        console.error('Failed to copy terminal content:', err);
                    });
            } else {
                log('Terminal is empty, nothing to copy.', 'info');
            }
        });

        // Function to get a promise and its resolver
        function getPromiseAndResolve() {
            let resolve;
            let promise = new Promise((res) => {
                resolve = res;
            });
            return { promise, resolve };
        }

        // Unique ID generation for messages
        let lastId = 1;
        function getId() {
            return lastId++;
        }

        // Run a Python script in a worker
        async function runPythonScript(scriptContent, context = {}, additionalFiles = []) {
            // Check for common Python main block patterns
            const mainPatterns = [
                'if __name__ == "__main__":',
                "if __name__ == '__main__':",
                'if __name__ in ["__main__"]',
                "if __name__ in ['__main__']",
                '__name__ == "__main__"',
                "__name__ == '__main__'"
            ];
            
            const hasMainPattern = mainPatterns.some(pattern => scriptContent.includes(pattern));
            if (hasMainPattern) {
                log('Info: Script uses main block pattern. Automatically fixing for Pyodide compatibility.', 'info');
                // Prepend __name__ fix to the script content
                scriptContent = `__name__ = '__main__'\n${scriptContent}`;
            }
            
            // Create a new worker for each script
            const worker = createWorker();
            
            // Create a new promise to wait for the result
            const { promise, resolve } = getPromiseAndResolve();
            const scriptId = getId();
            
            // Set up message handler
            worker.onmessage = function(event) {
                const data = event.data;
                
                // Check if this is a response to our request
                if (data.id === scriptId) {
                    if (data.status === "complete") {
                        // Script completed successfully
                        log(`Script execution completed for ${data.scriptName || 'script'}`, 'success');
                        
                        // Log stdout and stderr
                        if (data.stdout) {
                            log(`Python stdout from ${data.scriptName || 'script'}:\n${data.stdout}`);
                        }
                        
                        if (data.stderr && data.stderr.trim()) {
                            log(`Python stderr from ${data.scriptName || 'script'}:\n${data.stderr}`, 'error');
                        }
                        
                        // Terminate the worker to free memory
                        worker.terminate();
                        log(`Web worker terminated for ${data.scriptName || 'script'}`, 'info');
                        
                        resolve(data);
                    } else if (data.status === "error") {
                        // Script execution failed
                        log(`Python Error in ${data.scriptName || 'script'}: ${data.error}`, 'error');
                        
                        // Log stderr if available
                        if (data.stderr && data.stderr.trim()) {
                            log(`Python stderr from ${data.scriptName || 'script'}:\n${data.stderr}`, 'error');
                        }
                        
                        // Terminate the worker to free memory even on error
                        worker.terminate();
                        log(`Web worker terminated for ${data.scriptName || 'script'}`, 'info');
                        
                        resolve(data);
                    } else {
                        // Status update
                        log(`Pyodide (${data.scriptName || 'script'}): ${data.status}`);
                    }
                }
            };
            
            // Convert file contents to ArrayBuffer for file transfer
            const fileData = await Promise.all(additionalFiles.map(async (file) => {
                return {
                    name: file.name,
                    data: await file.arrayBuffer()
                };
            }));
            
            // Send the script to the worker
            log(`Starting Python execution for ${additionalFiles.find(f => f.name.endsWith('.py'))?.name || 'script'}...`);
            worker.postMessage({
                id: scriptId,
                python: scriptContent,
                context,
                files: fileData,
                // Pass script name for logging, find it from pythonScripts array using content or fileObject.name
                scriptName: pythonScripts.find(s => s.content === scriptContent || (s.fileObject && additionalFiles.length > 0 && s.fileObject.name === additionalFiles[0].name))?.name 
            });
            
            return promise;
        }

        // Update the file drop zone with required files and drop all tile
        function updateFileDropZone() {
            const instructions = document.getElementById('fileDropZoneInstructions');
            fileDropZoneList.innerHTML = '';
            
            if (pythonScripts.length === 0) {
                if (userFiles.length === 0) {
                    instructions.style.display = 'block';
                    instructions.innerHTML = '<p>Load scripts to see required files</p>';
                } else {
                    instructions.style.display = 'none';
                    // Show user files even without scripts
                    userFiles.forEach(file => {
                        const tile = document.createElement('div');
                        tile.className = 'file-tile light-green';
                        tile.dataset.fileName = file.name;
                        tile.innerHTML = `
                            <div class="details">
                                <span class="file-name">${file.name}</span>
                                <span class="file-info">User file - ${(file.size / 1024).toFixed(1)} KB</span>
                            </div>
                        `;
                        tile.addEventListener('click', () => {
                            clearAllSelections();
                            tile.classList.add('selected');
                            previewFile(file);
                        });
                        fileDropZoneList.appendChild(tile);
                    });
                }
                return;
            }
            
            instructions.style.display = 'none';
            fileDropZoneList.innerHTML = '';
            
            // Collect all unique user file requirements from all scripts
            const allRequiredUserFiles = new Set();
            pythonScripts.forEach(script => {
                script.userFiles.forEach(fileName => allRequiredUserFiles.add(fileName));
            });
            
            // Add Drop All tile
            const dropAllTile = document.createElement('div');
            dropAllTile.className = 'drop-all-tile';
            dropAllTile.innerHTML = '<strong>Drop All</strong><br><span style="font-size: 0.8rem;">Drop multiple files here for auto-matching</span>';
            
            // Add click handler
            dropAllTile.addEventListener('click', () => {
                const input = document.createElement('input');
                input.type = 'file';
                input.multiple = true;
                input.onchange = (e) => {
                    if (e.target.files.length > 0) {
                        handleDropAllFiles(Array.from(e.target.files));
                    }
                };
                input.click();
            });
            
            // Add drag and drop handlers specifically for Drop All
            dropAllTile.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropAllTile.style.backgroundColor = '#ffecb5';
            });
            
            dropAllTile.addEventListener('dragleave', () => {
                dropAllTile.style.backgroundColor = '#fff3cd';
            });
            
            dropAllTile.addEventListener('drop', (e) => {
                e.preventDefault();
                e.stopPropagation(); // Prevent parent drop zone from handling
                dropAllTile.style.backgroundColor = '#fff3cd';
                handleDropAllFiles(Array.from(e.dataTransfer.files));
            });
            
            fileDropZoneList.appendChild(dropAllTile);
            
            // Add tiles for each required user file
            allRequiredUserFiles.forEach(fileName => {
                const tile = document.createElement('div');
                const userFile = userFiles.find(f => f.name === fileName);
                const isHollow = !userFile;
                
                tile.className = `file-tile ${isHollow ? 'hollow' : 'filled'}`;
                tile.innerHTML = `
                    <div class="details">
                        <span class="file-name">${fileName}</span>
                        <span class="file-info">${isHollow ? 'Required - click to select or drag file here' : 'Loaded - ' + (userFile.size / 1024).toFixed(1) + ' KB'}</span>
                    </div>
                `;
                
                if (isHollow) {
                    tile.addEventListener('click', () => {
                        const input = document.createElement('input');
                        input.type = 'file';
                        input.onchange = (e) => {
                            if (e.target.files[0]) {
                                handleSpecificFileSelection(e.target.files[0], fileName);
                            }
                        };
                        input.click();
                    });
                    
                    // Add drag and drop for hollow tiles
                    tile.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        tile.style.opacity = '1';
                        tile.style.backgroundColor = 'var(--drop-zone-hover)';
                    });
                    
                    tile.addEventListener('dragleave', () => {
                        tile.style.opacity = '0.7';
                        tile.style.backgroundColor = '#f8f9fa';
                    });
                    
                    tile.addEventListener('drop', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        tile.style.opacity = '0.7';
                        tile.style.backgroundColor = '#f8f9fa';
                        if (e.dataTransfer.files[0]) {
                            handleSpecificFileSelection(e.dataTransfer.files[0], fileName);
                        }
                    });
                } else {
                    tile.addEventListener('click', () => {
                        clearAllSelections();
                        tile.classList.add('selected');
                        previewFile(userFile);
                    });
                }
                
                fileDropZoneList.appendChild(tile);
            });
            
            // Add any non-matched files with light green background
            userFiles.forEach(file => {
                if (!allRequiredUserFiles.has(file.name)) {
                    const tile = document.createElement('div');
                    tile.className = 'file-tile light-green';
                    tile.dataset.fileName = file.name;
                    tile.innerHTML = `
                        <div class="details">
                            <span class="file-name">${file.name}</span>
                            <span class="file-info">Non-matched file - ${(file.size / 1024).toFixed(1)} KB</span>
                        </div>
                    `;
                    tile.addEventListener('click', () => {
                        clearAllSelections();
                        tile.classList.add('selected');
                        previewFile(file);
                    });
                    fileDropZoneList.appendChild(tile);
                }
            });
        }

        // Handle file selection - modified to distinguish drop zones
        function handleFileSelect(files, dropZoneId) {
            if (dropZoneId === 'scriptZone') {
                addPythonScripts(Array.from(files));
            } else if (dropZoneId === 'fileDropZone') {
                // Files dropped in the file drop zone - these are user files
                addUserFiles(Array.from(files));
            }
        }

        // Add Python scripts
        async function addPythonScripts(files) {
            const pyFiles = files.filter(file => file.name.toLowerCase().endsWith('.py'));
            if (pyFiles.length === 0) return;

            const scriptZoneInstructions = document.getElementById('scriptZoneInstructions');
            if (scriptZoneInstructions) {
                scriptZoneInstructions.style.display = 'none';
            }

            for (const file of pyFiles) {
                if (!pythonScripts.some(ps => ps.name === file.name)) {
                    try {
                        const content = await file.text();
                        const requiredFiles = parseRequiredFiles(content);
                        const newScript = {
                            name: file.name,
                            content: content,
                            userFiles: requiredFiles.userFiles || [],
                            processFiles: requiredFiles.processFiles || [],
                            fileObject: file,
                            id: `py-${file.name.replace(/[^a-zA-Z0-9]/g, '-')}`
                        };
                        pythonScripts.push(newScript);
                        log(`Added Python script: ${file.name} (User files: ${newScript.userFiles.join(', ') || 'none'}, Process files: ${newScript.processFiles.join(', ') || 'none'})`);
                    } catch (e) {
                        log(`Error reading Python file ${file.name}: ${e.message}`, 'error');
                    }
                } else {
                    log(`Python script ${file.name} already exists`, 'warning');
                }
            }
            pythonScripts.sort((a, b) => a.name.localeCompare(b.name));
            updateScriptsList();
            updateFileDropZone();
            updateRunButtonState();
        }

        // Parse magic comments for user_files and process_files
        function parseRequiredFiles(scriptContent) {
            const userFilesRegex = /#\s*user_files:\s*(.*)/i;
            const processFilesRegex = /#\s*process_files:\s*(.*)/i;
            
            const userFilesMatch = scriptContent.match(userFilesRegex);
            const processFilesMatch = scriptContent.match(processFilesRegex);
            
            const userFiles = userFilesMatch && userFilesMatch[1] 
                ? userFilesMatch[1].split(',').map(f => f.trim()).filter(f => f.length > 0)
                : [];
                
            const processFiles = processFilesMatch && processFilesMatch[1]
                ? processFilesMatch[1].split(',').map(f => f.trim()).filter(f => f.length > 0)
                : [];
                
            return { userFiles, processFiles };
        }
        
        // Add user files (files dropped in the file drop zone)
        function addUserFiles(files) {
            files.forEach(file => {
                if (!userFiles.some(f => f.name === file.name)) {
                    userFiles.push(file);
                    log(`Added user file: ${file.name}`);
                } else {
                    log(`User file ${file.name} already exists`, 'warning');
                }
            });
            updateFileDropZone();
            updateOutputFilesList();
        }
        
        // Add process files (files created by script execution)
        function addProcessFiles(files) {
            files.forEach(file => {
                if (!processFiles.some(f => f.name === file.name)) {
                    processFiles.push(file);
                    log(`Added process file: ${file.name}`);
                } else {
                    // Replace existing process file
                    const index = processFiles.findIndex(f => f.name === file.name);
                    processFiles[index] = file;
                    log(`Updated process file: ${file.name}`);
                }
            });
            updateOutputFilesList();
        }


        // Handle Drop All files functionality
        function handleDropAllFiles(files) {
            const filesToAdd = [];
            
            files.forEach(file => {
                // Check if this file matches any required user file
                const allRequiredUserFiles = new Set();
                pythonScripts.forEach(script => {
                    script.userFiles.forEach(fileName => allRequiredUserFiles.add(fileName));
                });
                
                if (!userFiles.some(f => f.name === file.name)) {
                    filesToAdd.push(file);
                    if (allRequiredUserFiles.has(file.name)) {
                        log(`Auto-matched file: ${file.name}`);
                    } else {
                        log(`Added non-matched file: ${file.name}`);
                    }
                }
            });
            
            // Add all files at once
            filesToAdd.forEach(file => userFiles.push(file));
            updateFileDropZone();
        }
        
        // Handle specific file selection for a required file tile
        function handleSpecificFileSelection(file, expectedFileName) {
            if (file.name === expectedFileName) {
                // Exact match
                if (!userFiles.some(f => f.name === file.name)) {
                    userFiles.push(file);
                    log(`Added required file: ${file.name}`);
                    updateFileDropZone();
                }
            } else {
                // Name mismatch - ask user if they want to rename
                if (confirm(`File name "${file.name}" doesn't match expected "${expectedFileName}". Rename the file to match?`)) {
                    // Create a new file with the expected name
                    const renamedFile = new File([file], expectedFileName, { type: file.type, lastModified: file.lastModified });
                    if (!userFiles.some(f => f.name === expectedFileName)) {
                        userFiles.push(renamedFile);
                        log(`Added and renamed file: ${file.name} -> ${expectedFileName}`);
                        updateFileDropZone();
                    }
                } else {
                    log(`File selection cancelled for ${expectedFileName}`);
                }
            }
        }
        
        // Update scripts list display
        function updateScriptsList() {
            scriptsList.innerHTML = ''; // Clear existing tiles

            // Add Run All button if there are scripts
            if (pythonScripts.length > 0) {
                const runAllButton = document.createElement('button');
                runAllButton.className = 'btn btn-run';
                runAllButton.textContent = 'Run All';
                runAllButton.style.marginBottom = '15px';
                runAllButton.id = 'runAllScriptsBtn';
                runAllButton.addEventListener('click', () => {
                    executeAllScripts();
                });
                scriptsList.appendChild(runAllButton);
            }

            pythonScripts.forEach(script => {
                const tile = document.createElement('div');
                tile.className = 'file-tile';
                tile.dataset.scriptName = script.name;
                
                const userFilesText = script.userFiles.length > 0 ? script.userFiles.join(', ') : 'None';
                const processFilesText = script.processFiles.length > 0 ? script.processFiles.join(', ') : 'None';
                
                tile.innerHTML = `
                    <div class="details">
                        <span class="file-name">${script.name}</span>
                        <span class="file-info">User files: ${userFilesText}<br>Process files: ${processFilesText}</span>
                    </div>
                `;
                tile.addEventListener('click', () => {
                    // Clear all selections first
                    clearAllSelections();
                    
                    // Toggle script selection
                    if (activeScript && activeScript.name === script.name) {
                        activeScript = null;
                    } else {
                        activeScript = script;
                        tile.classList.add('selected');
                    }
                    updateRunButtonState();
                    
                    // Preview the clicked Python script file
                    if (script.fileObject) {
                        previewFile(script.fileObject);
                    }
                });
                scriptsList.appendChild(tile);
            });
            updateRunButtonState();
        }
        
        
        // Update output files list display
        function updateOutputFilesList() {
            const instructions = document.getElementById('fileOutputInstructions');
            
            if (processFiles.length === 0) {
                instructions.style.display = 'block';
                instructions.innerHTML = '<p>Output Files</p><p class="sub-text">Waiting for output</p>';
                outputFilesList.innerHTML = '';
                return;
            }
            
            instructions.style.display = 'none';
            outputFilesList.innerHTML = '';
            
            // Add Download All button
            const downloadAllButton = document.createElement('button');
            downloadAllButton.className = 'btn btn-download';
            downloadAllButton.textContent = 'Download All';
            downloadAllButton.style.marginBottom = '15px';
            downloadAllButton.addEventListener('click', () => {
                downloadFiles(processFiles);
            });
            outputFilesList.appendChild(downloadAllButton);
            
            processFiles.forEach(file => {
                const tile = document.createElement('div');
                tile.className = 'file-tile filled';
                tile.dataset.fileName = file.name; // Add data attribute for selection tracking
                tile.innerHTML = `
                    <div class="details">
                        <span class="file-name">${file.name}</span>
                        <span class="file-info">Output file - ${(file.size / 1024).toFixed(1)} KB</span>
                    </div>
                `;
                tile.addEventListener('click', () => {
                    clearAllSelections();
                    tile.classList.add('selected');
                    previewFile(file);
                });
                outputFilesList.appendChild(tile);
            });
        }
        
        // Download files function
        function downloadFiles(files) {
            if (files.length === 1) {
                // Single file download
                const file = files[0];
                const downloadUrl = URL.createObjectURL(file);
                const a = document.createElement('a');
                a.href = downloadUrl;
                a.download = file.name;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(downloadUrl);
                log(`Downloaded file: ${file.name}`, 'success');
            } else if (files.length > 1) {
                // Multiple files - create a zip file
                log('Preparing to download multiple files as zip...', 'info');
                
                // Create script element for JSZip
                const script = document.createElement('script');
                script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
                script.onload = async () => {
                    try {
                        const zip = new JSZip();
                        
                        files.forEach(file => {
                            zip.file(file.name, file);
                        });
                        
                        const zipContent = await zip.generateAsync({ type: 'blob' });
                        
                        const downloadUrl = URL.createObjectURL(zipContent);
                        const a = document.createElement('a');
                        a.href = downloadUrl;
                        a.download = 'output-files.zip';
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(downloadUrl);
                        
                        log(`Downloaded ${files.length} files as zip`, 'success');
                    } catch (error) {
                        log(`Error creating zip file: ${error.message}`, 'error');
                    }
                };
                
                script.onerror = () => {
                    log('Failed to load JSZip library. Check your internet connection.', 'error');
                };
                
                document.head.appendChild(script);
            }
        }
        
        // Update run button state (simplified since button is now in script list)
        function updateRunButtonState() {
            // Button state is now handled automatically in updateScriptsList()
            // This function is kept for compatibility but does nothing
        }
        
        // Get files needed for script execution
        function getFilesForScript(script) {
            const filesToInclude = [];
            
            // Add required user files
            script.userFiles.forEach(fileName => {
                const userFile = userFiles.find(f => f.name === fileName);
                if (userFile) {
                    filesToInclude.push(userFile);
                } else {
                    log(`Warning: Required user file '${fileName}' not found for script '${script.name}'`, 'warning');
                }
            });
            
            // Add required process files
            script.processFiles.forEach(fileName => {
                const processFile = processFiles.find(f => f.name === fileName);
                if (processFile) {
                    filesToInclude.push(processFile);
                } else {
                    log(`Warning: Required process file '${fileName}' not found for script '${script.name}'`, 'warning');
                }
            });
            
            // Add all non-matched user files (light green)
            const allRequiredUserFiles = new Set();
            pythonScripts.forEach(s => {
                s.userFiles.forEach(fileName => allRequiredUserFiles.add(fileName));
            });
            
            userFiles.forEach(file => {
                if (!allRequiredUserFiles.has(file.name) && !filesToInclude.includes(file)) {
                    filesToInclude.push(file);
                }
            });
            
            return filesToInclude;
        }

        // Function to execute all scripts (called by the dynamic Run All button)
        async function executeAllScripts() {
            if (pythonScripts.length === 0) {
                log("No Python scripts to run.", "warning");
                return;
            }

            // Always run all scripts (simplified from the old button logic)
            log(`Preparing to execute all ${pythonScripts.length} Python script(s)...`);
            
            for (const script of pythonScripts) {
                const filesForThisScript = getFilesForScript(script);
                
                log(`Script ${script.name} will run with files: ${filesForThisScript.map(f => f.name).join(', ') || 'none'}`, "info");
                
                log(`Running script: ${script.name}`);
                await executePythonFileInternal(script.fileObject, script.content, filesForThisScript);
            }
            log("Finished running all Python scripts.", "success");
        }

        // Update the preview panel to show file properties at the top
        function updatePreviewWithFileInfo(file) {
            // Create file info section
            const fileInfo = document.createElement('div');
            fileInfo.style.padding = '0 0 15px 0';
            fileInfo.style.borderBottom = '1px solid #eee';
            fileInfo.style.marginBottom = '15px';
            fileInfo.style.fontSize = '0.9rem';
            
            const sizeString = file.size < 1024 
                ? file.size + ' B'
                : file.size < 1024 * 1024
                    ? (file.size / 1024).toFixed(1) + ' KB'
                    : (file.size / (1024 * 1024)).toFixed(1) + ' MB';
                    
            const date = new Date(file.lastModified);
            const dateString = date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
            
            fileInfo.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                    <strong>${file.name}</strong>
                    <div>
                        <span style="color: var(--secondary-text); margin-right: 10px;">Size: ${sizeString}</span>
                        <button class="btn btn-download preview-download-btn" style="padding: 4px 8px; font-size: 0.8rem;">Download</button>
                    </div>
                </div>
                <div style="color: var(--secondary-text); font-size: 0.8rem;">
                    Last Modified: ${dateString}
                </div>
            `;
            
            // Add download functionality to the button
            setTimeout(() => {
                const downloadBtn = fileInfo.querySelector('.preview-download-btn');
                if (downloadBtn) {
                    downloadBtn.addEventListener('click', () => {
                        downloadFiles([file]);
                    });
                }
            }, 0);
            
            return fileInfo;
        }

        // Calculate SHA-256 checksum for a file
        async function calculateFileChecksum(fileData) {
            const hashBuffer = await crypto.subtle.digest('SHA-256', fileData);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
        }
        
        // Process modified files returned from Pyodide
        async function handleModifiedFiles(modifiedFiles, inputFileChecksums = {}) {
            if (!modifiedFiles || modifiedFiles.length === 0) {
                return;
            }
            
            log(`Processing ${modifiedFiles.length} files from Python execution...`, 'info');
            
            const newProcessFiles = [];
            
            // Process each modified file
            for (const modifiedFile of modifiedFiles) {
                // Calculate checksum of the output file
                const outputChecksum = await calculateFileChecksum(modifiedFile.data);
                const inputChecksum = inputFileChecksums[modifiedFile.name];
                
                // Only include if file is new or has changed
                if (!inputChecksum || outputChecksum !== inputChecksum) {
                    // Create a File object from the binary data
                    const blob = new Blob([modifiedFile.data], { type: 'application/octet-stream' });
                    const file = new File([blob], modifiedFile.name, { 
                        lastModified: new Date().getTime() 
                    });
                    
                    newProcessFiles.push(file);
                    
                    if (inputChecksum) {
                        log(`Modified file: ${modifiedFile.name}`, 'success');
                    } else {
                        log(`New output file: ${modifiedFile.name}`, 'success');
                    }
                } else {
                    log(`Skipped unchanged file: ${modifiedFile.name}`, 'info');
                }
            }
            
            // Add to process files only if there are new/modified files
            if (newProcessFiles.length > 0) {
                addProcessFiles(newProcessFiles);
            } else {
                log('No new or modified files to add to output.', 'info');
            }
        }
        
        // Execute a Python file using a web worker
        async function executePythonFile(file) { // file is the Python File object being previewed
            log(`Preparing to execute ${file.name} from preview...`);
            const scriptToRun = pythonScripts.find(ps => ps.name === file.name);
            
            if (!scriptToRun) {
                log(`Error: Script ${file.name} not found in the list of runnable Python scripts.`, 'error');
                return;
            }

            const filesToInclude = getFilesForScript(scriptToRun);
            log(`Running ${scriptToRun.name} from preview with files: ${filesToInclude.map(f=>f.name).join(', ') || 'none'}`, "info");
            
            await executePythonFileInternal(scriptToRun.fileObject, scriptToRun.content, filesToInclude);
        }

        // Internal function to handle actual execution, called by both run button types
        async function executePythonFileInternal(pyFileObject, scriptContent, dataFilesToInclude) {
            log(`Executing ${pyFileObject.name} with ${dataFilesToInclude.length} data file(s)`);

            try {
                // Calculate checksums of input files before execution
                const inputFileChecksums = {};
                for (const file of dataFilesToInclude) {
                    const fileData = await file.arrayBuffer();
                    inputFileChecksums[file.name] = await calculateFileChecksum(fileData);
                }
                
                const result = await runPythonScript(scriptContent, {}, dataFilesToInclude);
                
                if (result.status === "complete") {
                    if (result.result) {
                        log(`Result from ${pyFileObject.name}: ${result.result}`);
                    }
                    
                    if (result.modifiedFiles && result.modifiedFiles.length > 0) {
                        await handleModifiedFiles(result.modifiedFiles, inputFileChecksums);
                    }
                    
                    // Mark script as successfully run
                    markScriptAsSuccessful(pyFileObject.name);
                }
            } catch (error) {
                log(`Failed to execute ${pyFileObject.name}: ${error}`, 'error');
            }
        }
        
        // Mark a script tile as successful
        function markScriptAsSuccessful(scriptName) {
            const scriptTiles = scriptsList.querySelectorAll('.file-tile');
            scriptTiles.forEach(tile => {
                if (tile.dataset.scriptName === scriptName) {
                    tile.classList.add('success');
                }
            });
        }


        // Clear all selections across all zones
        function clearAllSelections() {
            document.querySelectorAll('.file-tile.selected').forEach(tile => {
                tile.classList.remove('selected');
            });
            activeScript = null;
            updateRunButtonState();
        }
        
        // Select a file for preview
        function selectFile(file) {
            selectedFile = file;
            clearAllSelections();
            previewFile(file);
        }

        // Preview parquet file using JavaScript hyparquet
        async function previewParquetFile(file) {
            log(`Loading parquet preview for ${file.name}...`);
            
            // Create loading indicator
            const loadingDiv = document.createElement('div');
            loadingDiv.textContent = 'Loading parquet file...';
            loadingDiv.style.padding = '20px';
            previewPanel.appendChild(loadingDiv);
            
            try {
                // Load hyparquet from CDN
                const { parquetReadObjects, parquetMetadataAsync, parquetSchema } = 
                    await import('https://cdn.jsdelivr.net/npm/hyparquet/src/hyparquet.min.js');
                
                // Read file as ArrayBuffer
                const buffer = await file.arrayBuffer();
                
                // Get file metadata first
                const metadata = await parquetMetadataAsync(buffer);
                const schema = parquetSchema(metadata);
                
                // Get number of rows and column names
                const numRows = Number(metadata.num_rows);
                const columnNames = schema.children.map(e => e.element.name);
                
                // Preview max 100 rows
                const previewRows = 100;
                const data = await parquetReadObjects({
                    file: buffer,
                    columns: columnNames,
                    rowStart: 0,
                    rowEnd: Math.min(previewRows, numRows)
                });
                
                // Remove loading indicator
                loadingDiv.remove();
                
                // Create table container
                const tableContainer = document.createElement('div');
                tableContainer.style.overflow = 'auto';
                tableContainer.style.maxHeight = 'calc(100% - 120px)';
                tableContainer.style.boxSizing = 'border-box';
                
                // Create HTML table
                const table = document.createElement('table');
                table.className = 'parquet-table';
                table.style.width = '100%';
                
                // Create header
                const thead = document.createElement('thead');
                const headerRow = document.createElement('tr');
                
                // Add column headers
                columnNames.forEach(column => {
                    const th = document.createElement('th');
                    th.textContent = column;
                    headerRow.appendChild(th);
                });
                
                thead.appendChild(headerRow);
                table.appendChild(thead);
                
                // Create table body
                const tbody = document.createElement('tbody');
                
                // Add data rows
                data.forEach(row => {
                    const tr = document.createElement('tr');
                    
                    // Add cells for each column
                    columnNames.forEach(column => {
                        const td = document.createElement('td');
                        const value = row[column];
                        td.textContent = value !== null && value !== undefined ? value.toString() : 'null';
                        tr.appendChild(td);
                    });
                    
                    tbody.appendChild(tr);
                });
                
                table.appendChild(tbody);
                tableContainer.appendChild(table);
                previewPanel.appendChild(tableContainer);
                
                // Show metadata
                const metadataDiv = document.createElement('div');
                metadataDiv.style.marginTop = '15px';
                metadataDiv.style.fontSize = '0.9rem';
                metadataDiv.style.color = '#666';
                
                // Extract schema types for display
                const schemaInfo = columnNames.map(name => {
                    const child = schema.children.find(c => c.element.name === name);
                    return `${name}: ${child ? child.element.type : 'unknown'}`;
                }).join('\n');
                
                metadataDiv.innerHTML = `
                    <div style="margin-bottom: 10px;"><strong>Parquet File Info:</strong></div>
                    <div><strong>Rows:</strong> ${numRows}</div>
                    <div><strong>Columns:</strong> ${columnNames.length}</div>
                    <div><strong>Preview:</strong> Showing ${Math.min(previewRows, numRows)} of ${numRows} rows</div>
                    <div style="margin-top: 10px;"><strong>Schema:</strong></div>
                    <pre style="font-size: 0.8rem; margin-top: 5px;">${schemaInfo}</pre>
                `;
                
                previewPanel.appendChild(metadataDiv);
                
                log(`Parquet file loaded: ${columnNames.length} columns, ${numRows} rows`, 'success');
                
            } catch (error) {
                loadingDiv.remove();
                previewPanel.innerHTML += `<div class="error">Error reading parquet file: ${error.message}</div>`;
                log(`Error reading parquet file: ${error.message}`, 'error');
            }
        }
        
        // Preview HTML file in an iframe
        function previewHtmlFile(content) {
            // Create a container for the iframe
            const iframeContainer = document.createElement('div');
            iframeContainer.style.width = '100%';
            iframeContainer.style.height = '100%'; // Changed from '500px'
            iframeContainer.style.border = '1px solid #ddd';
            iframeContainer.style.borderRadius = '4px';
            iframeContainer.style.overflow = 'hidden';
            iframeContainer.style.flexGrow = '1'; // Added to fill flex container
            
            // Create the iframe
            const iframe = document.createElement('iframe');
            iframe.style.width = '100%';
            iframe.style.height = '100%';
            iframe.style.border = 'none';
            iframe.sandbox = 'allow-same-origin allow-scripts'; // Restrict capabilities for security, added allow-scripts
            
            // Append the iframe to the container
            iframeContainer.appendChild(iframe);
            previewPanel.appendChild(iframeContainer);
            
            // Set the iframe content
            setTimeout(() => {
                const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                iframeDoc.open();
                iframeDoc.write(content);
                iframeDoc.close();
            }, 0);
        }
        
        // Preview file content
        function previewFile(file) {
            previewPanel.innerHTML = ''; // Clear preview panel
            
            // Add file info at the top
            const fileInfo = updatePreviewWithFileInfo(file);
            previewPanel.appendChild(fileInfo);
            
            // For Python files, add a Run button
            const isPythonScript = file.name.toLowerCase().endsWith('.py') && pythonScripts.some(ps => ps.name === file.name);
            if (isPythonScript) {
                const runButton = document.createElement('button');
                runButton.className = 'run-button';
                runButton.textContent = 'Run Script';
                runButton.style.marginBottom = '15px';
                runButton.addEventListener('click', () => {
                    executePythonFile(file);
                });
                previewPanel.appendChild(runButton);
            }
            
            const ext = file.name.split('.').pop().toLowerCase();
            
            // Handle different file types
            if (ext === 'parquet') {
                // For parquet files, use pyodide with hyparquet to load and display
                previewParquetFile(file);
            } else if (ext === 'html') {
                // For HTML files, read as text and display in an iframe
                const fileReader = new FileReader();
                fileReader.onload = function(e) {
                    previewHtmlFile(e.target.result);
                };
                fileReader.onerror = function() {
                    previewPanel.innerHTML += '<div>Error reading HTML file.</div>';
                    log(`Error reading file: ${file.name}`, 'error');
                };
                fileReader.readAsText(file);
            } else if (ext === 'py' || ext === 'txt' || ext === 'json' || ext === 'csv') {
                // For text files, read and display as text
                const fileReader = new FileReader();
                fileReader.onload = function(e) {
                    const codePreview = document.createElement('pre');
                    codePreview.className = 'code-preview';
                    codePreview.textContent = e.target.result;
                    previewPanel.appendChild(codePreview);
                };
                fileReader.onerror = function() {
                    previewPanel.innerHTML += '<div>Error reading file.</div>';
                    log(`Error reading file: ${file.name}`, 'error');
                };
                fileReader.readAsText(file);
            } else {
                previewPanel.innerHTML += '<div>No preview available for this file type.</div>';
            }
            
            log(`Previewing: ${file.name}`);
        }

        // Setup drop zone
        function setupDropZone(dropZoneElement, zoneId) { // Added zoneId
            // Handle drag over
            dropZoneElement.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZoneElement.classList.add('active');
            });
            
            // Handle drag leave
            dropZoneElement.addEventListener('dragleave', () => {
                dropZoneElement.classList.remove('active');
            });
            
            // Handle drop
            dropZoneElement.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZoneElement.classList.remove('active');
                handleFileSelect(e.dataTransfer.files, zoneId); // Pass zoneId
            });
            
            // Handle click to select files (only for drop zones, not output panel)
            if (zoneId !== 'fileOutputZone') {
                dropZoneElement.addEventListener('click', (e) => {
                    // Simplified approach: block specific interactive elements, allow everything else
                    const isInteractiveElement = 
                        e.target.tagName === 'BUTTON' || // Buttons
                        e.target.closest('button') || // Elements inside buttons
                        e.target.classList.contains('file-tile') || // File tiles
                        e.target.closest('.file-tile') || // Elements inside file tiles
                        e.target.classList.contains('drop-all-tile') || // Drop all tile
                        e.target.closest('.drop-all-tile'); // Elements inside drop all tile
                    
                    if (!isInteractiveElement) {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        const input = document.createElement('input');
                        input.type = 'file';
                        input.multiple = true;
                        input.style.display = 'none';
                        
                        if (zoneId === 'scriptZone') {
                            input.accept = '.py';
                        }
                        
                        input.onchange = (event) => {
                            if (event.target.files.length > 0) {
                                handleFileSelect(event.target.files, zoneId);
                            }
                            // Clean up input element
                            document.body.removeChild(input);
                        };
                        
                        // Add to DOM temporarily for the click to work
                        document.body.appendChild(input);
                        input.click();
                    }
                });
            }
        }

        // Initialize
        function init() {
            setupDropZone(scriptZone, 'scriptZone'); // Setup for script zone
            setupDropZone(fileDropZone, 'fileDropZone'); // Setup for file drop zone
            log('App initialized and ready');
            log('Drag and drop Python scripts to the script zone, and data files will be managed based on script requirements.');
        }

        // Start the app
        init();
    </script>
</body>
</html>
