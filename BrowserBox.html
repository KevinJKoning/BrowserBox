<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BrowserBox</title>
    <style>
        :root {
            --primary-bg: #ffffff;
            --panel-bg: #f9f9f9;
            --border-color: #e0e0e0;
            --accent-color: #3498db;
            --text-color: #333333;
            --secondary-text: #666666;
            --terminal-bg: #2d3436;
            --terminal-text: #ecf0f1;
            --drop-zone-hover: rgba(52, 152, 219, 0.1);
            --new-file-indicator-bg: #d1e7dd; /* Light green for new files */
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        }

        body {
            background-color: var(--primary-bg);
            color: var(--text-color);
            height: 100vh;
            padding: 20px;
        }

        .container {
            display: grid;
            grid-template-columns: 1fr 1.5fr 1.5fr; /* python-scripts, data-files, preview */
            grid-template-rows: 2fr 1fr; /* main-content, terminal */
            grid-template-areas:
                "python-scripts data-files preview"
                "terminal terminal terminal";
            gap: 16px;
            height: calc(100vh - 40px);
        }

        .drop-zone {
            background-color: var(--panel-bg);
            border: 2px dashed #777777;
            border-radius: 8px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            transition: all 0.3s ease;
            overflow: auto;
        }
        
        .drop-zone #pythonInstructions,
        .drop-zone #dataInstructions {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            height: 100%;
        }

        .drop-zone:hover {
            background-color: var(--drop-zone-hover);
        }

        .drop-zone.active {
            border-color: var(--accent-color);
            background-color: var(--drop-zone-hover);
        }

        .drop-zone p {
            margin-bottom: 8px;
            font-weight: 500;
        }

        .python-script-tile {
            background-color: #e9ecef;
            border: 1px solid #ced4da;
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            font-size: 0.9rem;
            cursor: pointer; /* Add cursor pointer */
        }

        .python-script-tile.selected { /* New style for selected tile */
            border-color: var(--accent-color);
            background-color: var(--drop-zone-hover);
            box-shadow: 0 0 5px var(--accent-color);
        }

        .python-script-tile input[type="checkbox"] {
            margin-right: 10px;
            width: 16px;
            height: 16px;
        }

        .python-script-tile .details {
            flex-grow: 1;
        }

        .python-script-tile .script-name {
            font-weight: 500;
            display: block;
            margin-bottom: 4px;
        }

        .python-script-tile .required-files {
            font-size: 0.8rem;
            color: var(--secondary-text);
        }

        .sub-text {
            font-size: 0.8rem;
            color: var(--secondary-text);
        }

        .python-drop-zone { /* New class for Python drop zone */
            grid-area: python-scripts;
        }

        .data-files-drop-zone { /* Renamed from .files-drop */
            grid-area: data-files;
        }

        .preview-panel {
            grid-area: preview; /* Updated grid area name */
            background-color: var(--panel-bg);
            border-radius: 8px;
            padding: 20px;
            overflow: auto;
            display: flex;
            flex-direction: column;
            border: 2px solid #777777;
        }

        .preview-panel .empty-state {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100%;
            color: var(--secondary-text);
        }

        .terminal {
            grid-area: terminal;
            background-color: var(--terminal-bg);
            border-radius: 8px;
            color: var(--terminal-text);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .terminal-header {
            padding: 8px 16px;
            background-color: rgba(255, 255, 255, 0.05);
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .terminal-actions { /* New style for button group */
            display: flex;
            gap: 8px;
        }

        .terminal-header button {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            color: var(--terminal-text);
            padding: 2px 8px;
            cursor: pointer;
            font-size: 0.8rem;
        }

        .terminal-header button:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .terminal-content {
            padding: 16px;
            overflow-y: auto;
            flex-grow: 1;
            font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.4;
            white-space: pre-wrap;
        }

        .file-list {
            list-style: none;
            width: 100%;
            /* margin-top: 10px; */ /* Removed */
        }

        .python-files-list { /* New class for Python files list container */
            list-style: none;
            width: 100%;
            /* margin-top: 10px; */ /* Removed */
            max-height: calc(100% - 80px); /* Adjust based on button height etc. */
            overflow-y: auto;
        }

        .file-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
            font-size: 0.9rem;
        }

        .file-table th {
            text-align: left;
            padding: 6px 8px;
            border-bottom: 1px solid var(--border-color);
            font-weight: 500;
            color: var(--secondary-text);
        }
        
        /* Action buttons styling */
        .action-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .btn {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .btn-run {
            background-color: var(--accent-color);
            color: white;
        }
        
        .btn-run:hover:not(:disabled) {
            background-color: #2980b9;
        }

        .btn-download {
            background-color: #27ae60;
            color: white;
        }
        
        .btn-download:hover:not(:disabled) {
            background-color: #219651;
        }
        
        .btn-include {
            background-color: #8e44ad;
            color: white;
        }
        
        .btn-include:hover:not(:disabled) {
            background-color: #7d3c98;
        }
        
        /* Badge for included files */
        .included-badge {
            display: inline-block;
            background-color: #8e44ad;
            color: white;
            font-size: 0.7rem;
            padding: 2px 6px;
            border-radius: 10px;
            margin-left: 6px;
            vertical-align: middle;
        }
        
        /* Sortable table headers */
        .sortable {
            cursor: pointer;
            position: relative;
            padding-right: 18px !important;
        }
        
        .sortable:after {
            content: "â†‘â†“";
            font-size: 0.7em;
            position: absolute;
            right: 6px;
            opacity: 0.3;
        }
        
        .sortable.sort-active:after {
            opacity: 1;
        }
        
        .sortable.sort-asc:after {
            content: "â†‘";
        }
        
        .sortable.sort-desc:after {
            content: "â†“";
        }

        .file-table td {
            padding: 8px;
            border-bottom: 1px solid var(--border-color);
        }

        .file-row {
            cursor: pointer;
            transition: background-color 0.5s ease-out; /* Added transition for smooth highlight fade */
        }

        .file-row:hover {
            background-color: rgba(0, 0, 0, 0.05);
        }

        .file-row.active {
            background-color: var(--accent-color);
            color: white;
        }
        
        .file-row.active td {
            border-bottom-color: var(--accent-color);
        }

        .file-row.new-file-indicator { /* New class for highlighting new files */
            background-color: var(--new-file-indicator-bg);
        }

        .file-icon {
            margin-right: 4px;
            font-size: 1.1rem;
        }
        
        .file-checkbox {
            cursor: pointer;
            width: 16px;
            height: 16px;
        }

        .file-preview {
            width: 100%;
            height: 100%;
            overflow: auto;
            text-align: left;
        }

        .code-preview {
            padding: 16px;
            font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.4;
            background-color: #f5f5f5;
            border-radius: 4px;
            white-space: pre;
            overflow-x: auto;
        }

        .run-button {
            background-color: var(--accent-color);
            color: white;
            border: none;
            border-radius: 4px;
            padding: 6px 12px;
            margin-top: 12px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background-color 0.2s;
        }

        .run-button:hover {
            background-color: #2980b9;
        }

        .run-button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }
        
        /* Parquet table styling */
        .parquet-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9rem;
        }
        
        .parquet-table th {
            background-color: #f5f5f5;
            padding: 8px 12px;
            text-align: left;
            font-weight: 600;
            border-bottom: 2px solid #ddd;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        
        .parquet-table td {
            padding: 8px 12px;
            border-bottom: 1px solid #eee;
            white-space: nowrap;
            max-width: 300px;
            overflow: hidden;
            text-overflow: ellipsis;
            height: 36px; /* Fixed height for table rows */
            line-height: 20px; /* Line height for better text display */
        }
        
        .parquet-table tr:hover td {
            background-color: rgba(0, 0, 0, 0.02);
        }
        
        /* Error message styling */
        .error {
            color: #e74c3c;
            padding: 12px;
            background-color: #fdf1f0;
            border-left: 4px solid #e74c3c;
            margin: 10px 0;
            border-radius: 0 4px 4px 0;
        }

        /* For responsiveness */
        @media (max-width: 768px) {
            .container {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto 1fr;
                grid-template-areas:
                    "left-top"
                    "left-middle"
                    "right"
                    "terminal";
                height: auto;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="drop-zone python-drop-zone" id="pythonDropZone">
            <div class="action-buttons" id="pythonActionButtons" style="display: none;">
                <button id="runAllPythonScriptsBtn" class="btn btn-run" disabled>Run</button>
            </div>
            <div id="pythonDropZoneInstructions">
                <p>Drag and Drop Python Files (.py) Here</p>
            </div>
            <div id="pythonFilesList" class="python-files-list"></div>
        </div>

        <div class="drop-zone data-files-drop-zone" id="dataFilesDropZone">
            <div id="dataFilesInstructions">
                <p>Drag and Drop Data Files Here</p>
                <p class="sub-text">(.csv, .parquet, .json, etc.)</p>
            </div>
            <div id="dataFilesList" class="file-list"></div>
        </div>
        
        <div class="preview-panel" id="previewPanel">
            <div class="empty-state">Select a File to Preview</div>
        </div>
        
        <div class="terminal" id="terminal">
            <div class="terminal-header">
                <span>Terminal Output</span>
                <div class="terminal-actions">
                    <button id="copyTerminal">Copy</button>
                    <button id="clearTerminal">Clear</button>
                </div>
            </div>
            <div class="terminal-content" id="terminalContent"></div>
        </div>
    </div>

    <!-- Web Worker Blob URLs will be stored here -->
    <script id="webworker" type="text/worker-script">
        // This will be converted to a Blob URL and used to create the worker
        // webworker.js
        importScripts("https://cdn.jsdelivr.net/pyodide/v0.27.5/full/pyodide.js");

        let pyodide;
        
        async function loadPyodideAndPackages() {
            self.pyodide = await loadPyodide();
            return self.pyodide;
        }
        
        // Start loading pyodide when the worker starts
        let pyodideReadyPromise = loadPyodideAndPackages();

        self.onmessage = async function(event) {
            // Make sure pyodide is ready
            self.pyodide = await pyodideReadyPromise;
            
            const { id, python, context, files } = event.data;
            
            // Create a status update function to send progress back to main thread
            function sendStatus(status) {
                self.postMessage({ id, status });
            }
            
            try {
                sendStatus("Loading packages...");
                await self.pyodide.loadPackagesFromImports(python);
                
                // Create the data directory for files
                sendStatus("Setting up filesystem...");
                self.pyodide.runPython(`
                    import os
                    if not os.path.exists('/home/pyodide/data'):
                        os.makedirs('/home/pyodide/data')
                `);
                
                // Add any files to the virtual filesystem
                if (files && files.length > 0) {
                    sendStatus("Loading files into filesystem...");
                    
                    // Write each file to the virtual filesystem
                    for (const file of files) {
                        const path = `/home/pyodide/data/${file.name}`;
                        self.pyodide.FS.writeFile(path, new Uint8Array(file.data));
                    }
                }
                
                // Set up the context
                sendStatus("Preparing context...");
                const globals = self.pyodide.toPy(context || {});
                
                // Add utility functions to the context
                self.pyodide.runPython(`
                    import sys
                    import os
                    
                    # Set up data directory in path
                    data_dir = '/home/pyodide/data'
                    sys.path.append(data_dir)
                    
                    # Set current working directory to data directory
                    # This ensures all relative file operations happen in our data directory
                    os.chdir(data_dir)
                    
                    # Redirect stdout and stderr to capture output
                    import io
                    
                    class OutputCollector:
                        def __init__(self):
                            self.value = ""
                        
                        def write(self, text):
                            self.value += text
                            return len(text)
                        
                        def flush(self):
                            pass
                    
                    stdout_collector = OutputCollector()
                    stderr_collector = OutputCollector()
                    
                    old_stdout = sys.stdout
                    old_stderr = sys.stderr
                    
                    sys.stdout = stdout_collector
                    sys.stderr = stderr_collector
                `);
                
                // Run the Python code
                sendStatus("Running Python code...");
                const output = await self.pyodide.runPythonAsync(python, { globals });
                
                // Get captured stdout and stderr
                const stdout = self.pyodide.runPython("stdout_collector.value");
                const stderr = self.pyodide.runPython("stderr_collector.value");
                
                // Reset stdout and stderr
                self.pyodide.runPython(`
                    sys.stdout = old_stdout
                    sys.stderr = old_stderr
                `);
                
                // Collect all files from the virtual filesystem
                sendStatus("Collecting modified files...");
                const modifiedFiles = [];
                
                try {
                    // Make sure the data directory exists (it should, but double-check)
                    self.pyodide.runPython(`
                        import os
                        if not os.path.exists('/home/pyodide/data'):
                            os.makedirs('/home/pyodide/data')
                    `);
                    
                    // Get the list of files in the data directory
                    const dataFiles = self.pyodide.FS.readdir('/home/pyodide/data');
                    
                    // Filter out special entries . and ..
                    const regularFiles = dataFiles.filter(name => name !== '.' && name !== '..');
                    
                    sendStatus(`Found ${regularFiles.length} files to collect`);
                    
                    // Read each file and convert to transferable format
                    for (const fileName of regularFiles) {
                        try {
                            const path = `/home/pyodide/data/${fileName}`;
                            const content = self.pyodide.FS.readFile(path, { encoding: 'binary' });
                            
                            modifiedFiles.push({
                                name: fileName,
                                data: content
                            });
                            
                            sendStatus(`Collected file: ${fileName}`);
                        } catch (fileError) {
                            console.error(`Error reading file ${fileName}:`, fileError);
                            sendStatus(`Error collecting file: ${fileName}`);
                        }
                    }
                } catch (fsError) {
                    console.error("Error reading filesystem:", fsError);
                    sendStatus(`Error accessing filesystem: ${fsError.message}`);
                }
                
                // Send back results with modified files
                self.postMessage({
                    id,
                    status: "complete", 
                    result: output,
                    stdout,
                    stderr,
                    modifiedFiles: modifiedFiles
                });
                
            } catch (error) {
                // When there's an error, we should still try to get stderr if possible
                let stderr = "";
                try {
                    stderr = self.pyodide.runPython("stderr_collector.value");
                } catch (e) {
                    // If we can't get stderr from the collector, just use the error message
                    stderr = error.message || "Unknown error";
                }
                
                self.postMessage({
                    id, 
                    status: "error",
                    error: error.message,
                    stderr: stderr
                });
            }
        };
    </script>

    <script>
        // Store files
        const allFiles = []; // For data files
        const pythonScripts = []; // For python scripts { name, content, requiredFiles, fileObject, id, selectedDataFileNames: Set }
        let selectedFile = null; // For preview
        let activePythonScriptForDataSelection = null; // Tracks which Python script's requirements are shown
        
        // Map of active workers, keyed by script name
        const activeWorkers = {};

        // DOM Elements
        const pythonDropZone = document.getElementById('pythonDropZone'); 
        const pythonFilesList = document.getElementById('pythonFilesList'); 
        const runAllPythonScriptsBtn = document.getElementById('runAllPythonScriptsBtn'); // Updated ID

        const dataFilesDropZone = document.getElementById('dataFilesDropZone'); // Renamed
        const dataFilesList = document.getElementById('dataFilesList'); // Renamed
        const previewPanel = document.getElementById('previewPanel');
        const terminalContent = document.getElementById('terminalContent');
        const clearTerminalBtn = document.getElementById('clearTerminal');
        const copyTerminalBtn = document.getElementById('copyTerminal'); 

        // Create web worker from inline script
        function createWorker() {
            const workerScript = document.getElementById('webworker').textContent;
            const blob = new Blob([workerScript], { type: 'application/javascript' });
            const workerUrl = URL.createObjectURL(blob);
            return new Worker(workerUrl);
        }

        // Log to terminal
        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logElement = document.createElement('div');
            logElement.className = `log-entry ${type}`;
            logElement.innerHTML = `[${timestamp}] ${message}`;
            terminalContent.appendChild(logElement);
            terminalContent.scrollTop = terminalContent.scrollHeight;
            
            // Add styling for different log types if it doesn't exist
            if (!document.getElementById('log-styles')) {
                const styleEl = document.createElement('style');
                styleEl.id = 'log-styles';
                styleEl.textContent = `
                    .log-entry.error { color: #e74c3c; }
                    .log-entry.warning { color: #f39c12; }
                    .log-entry.success { color: #2ecc71; }
                `;
                document.head.appendChild(styleEl);
            }
        }

        // Clear terminal
        clearTerminalBtn.addEventListener('click', () => {
            terminalContent.innerHTML = '';
            log('Terminal cleared');
        });

        // Copy terminal content
        copyTerminalBtn.addEventListener('click', () => {
            const textToCopy = terminalContent.textContent;
            if (textToCopy) {
                navigator.clipboard.writeText(textToCopy)
                    .then(() => {
                        log('Terminal content copied to clipboard.', 'success');
                    })
                    .catch(err => {
                        log('Failed to copy terminal content: ' + err, 'error');
                        console.error('Failed to copy terminal content:', err);
                    });
            } else {
                log('Terminal is empty, nothing to copy.', 'info');
            }
        });

        // Function to get a promise and its resolver
        function getPromiseAndResolve() {
            let resolve;
            let promise = new Promise((res) => {
                resolve = res;
            });
            return { promise, resolve };
        }

        // Unique ID generation for messages
        let lastId = 1;
        function getId() {
            return lastId++;
        }

        // Run a Python script in a worker
        async function runPythonScript(scriptContent, context = {}, additionalFiles = []) {
            // Create a new worker for each script
            const worker = createWorker();
            
            // Create a new promise to wait for the result
            const { promise, resolve } = getPromiseAndResolve();
            const scriptId = getId();
            
            // Set up message handler
            worker.onmessage = function(event) {
                const data = event.data;
                
                // Check if this is a response to our request
                if (data.id === scriptId) {
                    if (data.status === "complete") {
                        // Script completed successfully
                        log(`Script execution completed for ${data.scriptName || 'script'}`, 'success');
                        
                        // Log stdout and stderr
                        if (data.stdout) {
                            log(`Python stdout from ${data.scriptName || 'script'}:\n${data.stdout}`);
                        }
                        
                        if (data.stderr && data.stderr.trim()) {
                            log(`Python stderr from ${data.scriptName || 'script'}:\n${data.stderr}`, 'error');
                        }
                        
                        resolve(data);
                    } else if (data.status === "error") {
                        // Script execution failed
                        log(`Python Error in ${data.scriptName || 'script'}: ${data.error}`, 'error');
                        
                        // Log stderr if available
                        if (data.stderr && data.stderr.trim()) {
                            log(`Python stderr from ${data.scriptName || 'script'}:\n${data.stderr}`, 'error');
                        }
                        
                        resolve(data);
                    } else {
                        // Status update
                        log(`Pyodide (${data.scriptName || 'script'}): ${data.status}`);
                    }
                }
            };
            
            // Convert file contents to ArrayBuffer for file transfer
            const fileData = await Promise.all(additionalFiles.map(async (file) => {
                return {
                    name: file.name,
                    data: await file.arrayBuffer()
                };
            }));
            
            // Send the script to the worker
            log(`Starting Python execution for ${additionalFiles.find(f => f.name.endsWith('.py'))?.name || 'script'}...`);
            worker.postMessage({
                id: scriptId,
                python: scriptContent,
                context,
                files: fileData,
                // Pass script name for logging, find it from pythonScripts array using content or fileObject.name
                scriptName: pythonScripts.find(s => s.content === scriptContent || (s.fileObject && additionalFiles.length > 0 && s.fileObject.name === additionalFiles[0].name))?.name 
            });
            
            return promise;
        }

        // Helper function to update a script's selected files with newly available required files
        function updateScriptSelectionsWithAvailableRequiredFiles(script) {
            if (!script || !script.requiredFiles || !script.selectedDataFileNames) return;
        
            script.requiredFiles.forEach(reqFileName => {
                const dataFileExists = allFiles.some(dataFile => dataFile.name === reqFileName);
                if (dataFileExists && !script.selectedDataFileNames.has(reqFileName)) {
                    script.selectedDataFileNames.add(reqFileName);
                    log(`Auto-included newly available required file '${reqFileName}' for script '${script.name}'.`, 'info');
                }
            });
        }

        // Handle file selection - modified to distinguish drop zones
        function handleFileSelect(files, dropZoneId) {
            if (dropZoneId === 'pythonDropZone') {
                addPythonScripts(Array.from(files));
            } else if (dropZoneId === 'dataFilesDropZone') {
                addDataFiles(Array.from(files));
            }
        }

        // Add Python scripts
        async function addPythonScripts(files) {
            const pyFiles = files.filter(file => file.name.toLowerCase().endsWith('.py'));
            if (pyFiles.length === 0) return;

            const pythonDropZoneInstructions = document.getElementById('pythonDropZoneInstructions');
            if (pythonDropZoneInstructions) {
                pythonDropZoneInstructions.style.display = 'none';
            }

            for (const file of pyFiles) {
                if (!pythonScripts.some(ps => ps.name === file.name)) {
                    try {
                        const content = await file.text();
                        const requiredFiles = parseRequiredFiles(content);
                        const newScript = {
                            name: file.name,
                            content: content,
                            requiredFiles: requiredFiles,
                            fileObject: file,
                            id: `py-${file.name.replace(/[^a-zA-Z0-9]/g, '-')}`,
                            selectedDataFileNames: new Set() // Initialize selectedDataFileNames
                        };
                        // Auto-select required files if they exist in allFiles
                        requiredFiles.forEach(reqFileName => {
                            if (allFiles.some(dataFile => dataFile.name === reqFileName)) {
                                newScript.selectedDataFileNames.add(reqFileName);
                            }
                        });
                        pythonScripts.push(newScript);
                        log(`Added Python script: ${file.name} (Requires: ${requiredFiles.join(', ') || 'none'})`);
                    } catch (e) {
                        log(`Error reading Python file ${file.name}: ${e.message}`, 'error');
                    }
                } else {
                    log(`Python script ${file.name} already exists`, 'warning');
                }
            }
            pythonScripts.sort((a, b) => a.name.localeCompare(b.name));
            updatePythonFilesList();
            updateRunButtonState();
        }

        // Parse # Required-Files: comment
        function parseRequiredFiles(scriptContent) {
            const regex = /#\s*Required-Files:\s*(.*)/i;
            const match = scriptContent.match(regex);
            if (match && match[1]) {
                return match[1].split(',').map(f => f.trim()).filter(f => f.length > 0);
            }
            return [];
        }
        
        // Add data files (modified from old handleFileSelect)
        function addDataFiles(files) {
            files.forEach(file => {
                if (!allFiles.some(f => f.name === file.name)) {
                    const fileObj = file;
                    fileObj.isPython = file.name.toLowerCase().endsWith('.py'); // Though data zone shouldn't get .py
                    allFiles.push(fileObj);
                    log(`Added data file: ${file.name}`);

                    // If a newly added data file is required by any Python script and not yet in its selections, add it.
                    // This makes auto-selection more dynamic.
                    pythonScripts.forEach(pScript => {
                        if (pScript.requiredFiles.includes(fileObj.name) && !pScript.selectedDataFileNames.has(fileObj.name)) {
                            // Check if this script is the active one, to potentially refresh UI if needed,
                            // but adding to selectedDataFileNames is the main part.
                            // This behavior means if a user explicitly unselected a required file,
                            // and then the file is re-added (e.g. deleted and re-dropped), it gets re-selected.
                            // This might be desired as "required" implies it should be there.
                            pScript.selectedDataFileNames.add(fileObj.name);
                        }
                    });

                } else {
                    log(`Data file ${file.name} already exists`, 'warning');
                }
            });
            updateDataFileList(); // This will rebuild the list and attach new checkbox listeners
            // If an active Python script dictates selections, re-apply them to reflect any newly added files that match requirements
            updateDataFileSelections(activePythonScriptForDataSelection);
        }


        // Update Python file list display
        function updatePythonFilesList() {
            pythonFilesList.innerHTML = ''; // Clear existing tiles

            pythonScripts.forEach(script => {
                const tile = document.createElement('div');
                tile.className = 'python-script-tile';
                tile.dataset.scriptName = script.name; // Store script name for identification
                tile.innerHTML = `
                    <div class="details">
                        <span class="script-name">${script.name}</span>
                        <span class="required-files">Requires: ${script.requiredFiles.join(', ') || 'None'}</span>
                    </div>
                `;
                tile.addEventListener('click', () => {
                    const clickedScriptName = script.name;
                    let newActiveScript = null;

                    if (activePythonScriptForDataSelection && activePythonScriptForDataSelection.name === clickedScriptName) {
                        // Clicked the currently active script tile: deselect it.
                        activePythonScriptForDataSelection = null;
                    } else {
                        // Clicked a new script tile or a script tile when none was active.
                        newActiveScript = pythonScripts.find(s => s.name === clickedScriptName);
                        activePythonScriptForDataSelection = newActiveScript;
                    }
                    updatePythonTileVisualState(); // Highlights the correct tile
                    updateDataFileSelections(activePythonScriptForDataSelection); // Updates checkboxes based on the new active script's stored selections, or clears them if null
                    updateRunButtonState(); // Add this call to update button text/state on selection change
                    
                    // Preview the clicked Python script file
                    if (script.fileObject) {
                        previewFile(script.fileObject);
                    }
                });
                pythonFilesList.appendChild(tile);
            });
            updateRunButtonState();
            updatePythonTileVisualState(); // Ensure visual state is correct after list update
        }
        
        function updatePythonTileVisualState() {
            const tiles = pythonFilesList.querySelectorAll('.python-script-tile');
            tiles.forEach(tile => {
                if (activePythonScriptForDataSelection && tile.dataset.scriptName === activePythonScriptForDataSelection.name) {
                    tile.classList.add('selected');
                } else {
                    tile.classList.remove('selected');
                }
            });
        }
        
        function updateDataFileSelections(pythonScript) { // pythonScript is the activePythonScriptForDataSelection or null
            const checkboxes = dataFilesList.querySelectorAll('.file-checkbox');
            
            if (pythonScript) {
                checkboxes.forEach(cb => {
                    const filename = cb.dataset.filename;
                    cb.checked = pythonScript.selectedDataFileNames.has(filename);
                });
            } else {
                // No python script active, general selection mode. Clear checkboxes.
                checkboxes.forEach(cb => cb.checked = false);
            }
            updateDataFilesActionAreaUI(pythonScript); 
        }
        
        function updateRunButtonState() {
            const pythonActionButtons = document.getElementById('pythonActionButtons');
            if (pythonScripts.length > 0) {
                pythonActionButtons.style.display = 'flex';
                runAllPythonScriptsBtn.disabled = false;
                if (activePythonScriptForDataSelection) {
                    runAllPythonScriptsBtn.textContent = 'Run';
                } else {
                    runAllPythonScriptsBtn.textContent = 'Run All';
                }
            } else {
                pythonActionButtons.style.display = 'none';
                runAllPythonScriptsBtn.disabled = true;
                runAllPythonScriptsBtn.textContent = 'Run'; // Reset to default or 'Run All'
            }
        }

        runAllPythonScriptsBtn.addEventListener('click', async () => {
            if (pythonScripts.length === 0) {
                log("No Python scripts to run.", "warning");
                return;
            }

            if (activePythonScriptForDataSelection) {
                // Run only the selected script
                const script = activePythonScriptForDataSelection;
                log(`Preparing to execute selected script: ${script.name}...`);
                
                // Recheck and include newly available required files
                updateScriptSelectionsWithAvailableRequiredFiles(script);

                const filesForThisScript = allFiles.filter(dataFile =>
                    script.selectedDataFileNames.has(dataFile.name)
                );

                if (filesForThisScript.length === 0) {
                    log(`Script ${script.name} will run without any additional data files (none selected for it).`, "info");
                } else {
                    log(`Script ${script.name} will run with data files: ${filesForThisScript.map(f => f.name).join(', ')}`, "info");
                }
                
                log(`Running script: ${script.name}`);
                await executePythonFileInternal(script.fileObject, script.content, filesForThisScript);
                log(`Finished running script: ${script.name}.`, "success");

            } else {
                // Run all scripts
                log(`Preparing to execute all ${pythonScripts.length} Python script(s)...`);
                
                for (const script of pythonScripts) {
                    // Recheck and include newly available required files
                    updateScriptSelectionsWithAvailableRequiredFiles(script);

                    const filesForThisScript = allFiles.filter(dataFile =>
                        script.selectedDataFileNames.has(dataFile.name)
                    );

                    if (filesForThisScript.length === 0) {
                        log(`Script ${script.name} will run without any additional data files (none selected for it).`, "info");
                    } else {
                        log(`Script ${script.name} will run with data files: ${filesForThisScript.map(f => f.name).join(', ')}`, "info");
                    }
                    
                    log(`Running script: ${script.name}`);
                    await executePythonFileInternal(script.fileObject, script.content, filesForThisScript);
                }
                log("Finished running all Python scripts.", "success");
            }
        });

        // Function to update action buttons state based on selections (for data files)
        function updateDataFileActionButtonsState() {
            const downloadButton = document.getElementById('downloadSelectedDataFiles');
            const checkedBoxes = dataFilesList.querySelectorAll('.file-checkbox:checked'); 
            const hasSelection = checkedBoxes.length > 0;
            
            if (downloadButton) downloadButton.disabled = !hasSelection;
        }

        // Update file list display (now for data files)
        function updateDataFileList() {
            const instructionsElement = document.getElementById('dataFilesInstructions');
            
            if (allFiles.length > 0) {
                instructionsElement.style.display = 'none';
            } else {
                instructionsElement.style.display = 'block'; // Changed from 'flex'
            }
            
            dataFilesList.innerHTML = ''; // Changed from filesList
            
            if (allFiles.length > 0) {
                const actionContainer = document.createElement('div');
                actionContainer.id = 'dataFilesActionContainer';
                actionContainer.style.display = 'flex';
                actionContainer.style.gap = '10px';
                actionContainer.style.marginBottom = '15px';
                actionContainer.style.alignItems = 'center'; // Vertically align items

                // Create Download Button
                const downloadButton = document.createElement('button');
                downloadButton.id = 'downloadSelectedDataFiles';
                downloadButton.className = 'btn btn-download';
                downloadButton.textContent = 'Download';
                downloadButton.disabled = true;
                actionContainer.appendChild(downloadButton);

                // Create Message Text
                const messageText = document.createElement('p');
                messageText.id = 'dataFilesMessageText';
                messageText.textContent = 'Files included with selected script';
                messageText.style.display = 'none'; // Initially hidden
                messageText.style.flexGrow = '1'; 
                messageText.style.textAlign = 'center';
                messageText.style.padding = '6px 0'; 
                messageText.style.fontSize = '0.9rem';
                messageText.style.color = 'var(--secondary-text)';
                actionContainer.appendChild(messageText);
                
                dataFilesList.appendChild(actionContainer);
            }
            
            if (allFiles.length > 0) {
                // Create table
                const table = document.createElement('table');
                table.className = 'file-table';
                
                // Create table header with sortable columns
                const thead = document.createElement('thead');
                thead.innerHTML = `
                    <tr>
                        <th><input type="checkbox" id="selectAllFiles"></th>
                        <th class="sortable sort-active sort-asc" data-sort="name">Name</th>
                        <th class="sortable" data-sort="size">Size</th>
                        <th class="sortable" data-sort="date">Last Modified</th>
                    </tr>
                `;
                table.appendChild(thead);
                
                // Create table body
                const tbody = document.createElement('tbody');
                allFiles.forEach(file => {
                    const tr = document.createElement('tr');
                    tr.className = 'file-row';
                    
                    // Format date
                    const date = new Date(file.lastModified);
                    const dateString = date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
                    
                    // Calculate size
                    const sizeString = file.size < 1024 
                        ? file.size + ' B'
                        : file.size < 1024 * 1024
                            ? (file.size / 1024).toFixed(1) + ' KB'
                            : (file.size / (1024 * 1024)).toFixed(1) + ' MB';
                    
                    // Store size value for sorting
                    const sizeBytes = file.size;
                    
                    // Store date for sorting
                    const dateValue = file.lastModified;
                    
                    tr.innerHTML = `
                        <td><input type="checkbox" class="file-checkbox" data-filename="${file.name}"></td>
                        <td data-value="${file.name}"><span class="file-icon">ðŸ“„</span>${file.name}</td>
                        <td data-value="${sizeBytes}">${sizeString}</td>
                        <td data-value="${dateValue}">${dateString}</td>
                    `;

                    // Apply highlight if file was just created by Pyodide
                    if (file.wasJustCreatedByPyodide) {
                        tr.classList.add('new-file-indicator');
                    }
                    
                    // Add data attributes for sorting
                    tr.dataset.name = file.name.toLowerCase();
                    tr.dataset.size = String(file.size);
                    tr.dataset.date = String(file.lastModified);
                    
                    // Add click handler for row
                    tr.addEventListener('click', (e) => {
                        // Don't trigger row selection when checkbox or button is clicked
                        if (e.target.type !== 'checkbox' && e.target.tagName !== 'BUTTON') {
                            selectFile(file);
                        }
                    });

                    // Add change listener for the checkbox
                    const checkbox = tr.querySelector('.file-checkbox');
                    checkbox.addEventListener('change', (event) => {
                        const filename = event.target.dataset.filename;
                        const isChecked = event.target.checked;

                        if (activePythonScriptForDataSelection) {
                            if (isChecked) {
                                activePythonScriptForDataSelection.selectedDataFileNames.add(filename);
                            } else {
                                activePythonScriptForDataSelection.selectedDataFileNames.delete(filename);
                            }
                            // No need to call updateDataFileSelections, UI is already updated.
                            // Download/Delete buttons are hidden, so their state update is not critical here.
                        } else {
                            // General selection mode (no Python script active)
                            updateDataFileActionButtonsState(); // Update Download/Delete button states
                        }
                    });
                    
                    tbody.appendChild(tr);
                });
                
                table.appendChild(tbody);
                dataFilesList.appendChild(table); // Changed from filesList
                
                // Add select all functionality
                const selectAllCheckbox = document.getElementById('selectAllFiles');
                selectAllCheckbox.addEventListener('change', () => {
                    const checkboxes = dataFilesList.querySelectorAll('.file-checkbox'); // Changed from filesList
                    checkboxes.forEach(checkbox => {
                        checkbox.checked = selectAllCheckbox.checked;
                    });
                    updateDataFileActionButtonsState(); // Renamed function
                });
                
                // Add sorting functionality to the table headers
                const sortableHeaders = thead.querySelectorAll('.sortable');
                sortableHeaders.forEach(header => {
                    header.addEventListener('click', () => {
                        const sortBy = header.dataset.sort;
                        const isAsc = header.classList.contains('sort-asc');
                        
                        // Reset all headers
                        sortableHeaders.forEach(h => {
                            h.classList.remove('sort-active', 'sort-asc', 'sort-desc');
                        });
                        
                        // Set active sort
                        header.classList.add('sort-active');
                        if (isAsc) {
                            header.classList.add('sort-desc');
                        } else {
                            header.classList.add('sort-asc');
                        }
                        
                        // Get all rows and convert to array for sorting
                        const rows = Array.from(tbody.querySelectorAll('tr'));
                        
                        // Sort the rows based on the selected column
                        rows.sort((a, b) => {
                            let aValue = a.dataset[sortBy];
                            let bValue = b.dataset[sortBy];
                            
                            // Special handling for size and date, which are numbers
                            if (sortBy === 'size' || sortBy === 'date') {
                                aValue = Number(aValue);
                                bValue = Number(bValue);
                            }
                            
                            if (aValue < bValue) return isAsc ? -1 : 1;
                            if (aValue > bValue) return isAsc ? 1 : -1;
                            return 0;
                        });
                        
                        // Clear and re-append sorted rows
                        tbody.innerHTML = '';
                        rows.forEach(row => tbody.appendChild(row));
                    });
                });
                
                // Add event listeners to all checkboxes to update action buttons state
                const checkboxes = dataFilesList.querySelectorAll('.file-checkbox'); // Changed from filesList
                checkboxes.forEach(checkbox => {
                    checkbox.addEventListener('change', updateDataFileActionButtonsState); // Renamed function
                });
                
                // No more individual run buttons in the table rows
                
                // REMOVE runSelectedFiles and includeInRunFiles button logic from here
                // as it's handled by the Python zone now.
                
                // Add download selected files functionality
                const downloadButton = document.getElementById('downloadSelectedDataFiles');
                if (downloadButton) { // Check if button exists
                    downloadButton.addEventListener('click', () => {
                        const selectedCheckboxes = dataFilesList.querySelectorAll('.file-checkbox:checked'); // Changed
                        if (selectedCheckboxes.length === 0) return;
                        
                        // Get selected files
                        const filesForDownload = [];
                        selectedCheckboxes.forEach(checkbox => {
                            const filename = checkbox.dataset.filename;
                            const file = allFiles.find(f => f.name === filename);
                            if (file) {
                                filesForDownload.push(file);
                            }
                        });
                        
                        // Handle downloads based on count
                        if (filesForDownload.length === 1) {
                            // Single file download
                            const file = filesForDownload[0];
                            const downloadUrl = URL.createObjectURL(file);
                            const a = document.createElement('a');
                            a.href = downloadUrl;
                            a.download = file.name;
                            document.body.appendChild(a);
                            a.click();
                            document.body.removeChild(a);
                            URL.revokeObjectURL(downloadUrl);
                            log(`Downloaded file: ${file.name}`, 'success');
                        } else if (filesForDownload.length > 1) {
                            // Multiple files - create a zip file
                            // First, dynamically load JSZip via script tag
                            log('Preparing to download multiple files as zip...', 'info');
                            
                            // Create script element for JSZip
                            const script = document.createElement('script');
                            script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
                            script.onload = async () => {
                                try {
                                    // JSZip is now available as a global variable
                                    const zip = new JSZip();
                                    
                                    // Add each file to the zip
                                    filesForDownload.forEach(file => {
                                        zip.file(file.name, file);
                                    });
                                    
                                    // Generate the zip file
                                    const zipContent = await zip.generateAsync({ type: 'blob' });
                                    
                                    // Create download link
                                    const downloadUrl = URL.createObjectURL(zipContent);
                                    const a = document.createElement('a');
                                    a.href = downloadUrl;
                                    a.download = 'files.zip';
                                    document.body.appendChild(a);
                                    a.click();
                                    document.body.removeChild(a);
                                    URL.revokeObjectURL(downloadUrl);
                                    
                                    log(`Downloaded ${filesForDownload.length} files as zip`, 'success');
                                } catch (error) {
                                    log(`Error creating zip file: ${error.message}`, 'error');
                                    console.error(error);
                                }
                            };
                            
                            script.onerror = () => {
                                log('Failed to load JSZip library. Check your internet connection.', 'error');
                            };
                            
                            // Add script to document to load it
                            document.head.appendChild(script);
                        }
                    });
                }
            }
            // After everything is built, set the correct UI state for the action area
            updateDataFilesActionAreaUI(activePythonScriptForDataSelection);
        }
        
        // New helper function to specifically update the UI of the action area
        function updateDataFilesActionAreaUI(pythonScript) {
            const downloadBtn = document.getElementById('downloadSelectedDataFiles');
            const messageEl = document.getElementById('dataFilesMessageText');

            if (downloadBtn && messageEl) {
                if (pythonScript) { // A Python script tile is selected
                    downloadBtn.style.display = 'none';
                    messageEl.style.display = 'block'; 
                } else { // No Python script tile is selected
                    downloadBtn.style.display = 'inline-block';
                    messageEl.style.display = 'none';
                    // Update button states only when in general selection mode
                    updateDataFileActionButtonsState();
                }
            }
            // If no pythonScript, updateDataFileActionButtonsState is called above.
            // If pythonScript is active, those buttons are hidden, so their state is less critical.
        }

        // Process modified files returned from Pyodide
        function handleModifiedFiles(modifiedFiles) {
            if (!modifiedFiles || modifiedFiles.length === 0) {
                return;
            }
            
            log(`Processing ${modifiedFiles.length} modified files from Python execution...`, 'info');
            
            // Process each modified file
            modifiedFiles.forEach(modifiedFile => {
                // Create a File object from the binary data
                const blob = new Blob([modifiedFile.data], { type: 'application/octet-stream' });
                const file = new File([blob], modifiedFile.name, { 
                    lastModified: new Date().getTime() 
                });
                
                // Set isPython property
                file.isPython = file.name.toLowerCase().endsWith('.py');
                
                // Check if this file already exists in our files array
                const existingFileIndex = allFiles.findIndex(f => f.name === modifiedFile.name);
                
                if (existingFileIndex >= 0) {
                    // Replace the existing file
                    allFiles[existingFileIndex] = file;
                    log(`Updated file: ${modifiedFile.name}`, 'success');
                } else {
                    // Add as a new file
                    file.wasJustCreatedByPyodide = true; // Flag for visual indicator
                    allFiles.push(file);
                    log(`Added new file from Python: ${modifiedFile.name}`, 'success');
                }
            });
            
            // Refresh the file list display
            updateDataFileList();
        }
        
        // Execute a Python file using a web worker
        async function executePythonFile(file) { // file is the Python File object being previewed
            log(`Preparing to execute ${file.name} from preview...`);
            const scriptToRun = pythonScripts.find(ps => ps.name === file.name);
            
            if (!scriptToRun) {
                log(`Error: Script ${file.name} not found in the list of runnable Python scripts. Attempting to read content directly.`, 'error');
                try {
                    const content = await file.text(); 
                    await executePythonFileInternal(file, content, []); // Run with no data files
                } catch (readError) {
                    log(`Error reading content for ${file.name}: ${readError.message}`, 'error');
                }
                return;
            }

            // Recheck and include newly available required files
            updateScriptSelectionsWithAvailableRequiredFiles(scriptToRun);

            const dataFilesToInclude = allFiles.filter(dataFile =>
                scriptToRun.selectedDataFileNames.has(dataFile.name)
            );

            if (dataFilesToInclude.length === 0) {
                log(`Running ${scriptToRun.name} from preview without any additional data files (none selected for this script).`, "info");
            } else {
                log(`Running ${scriptToRun.name} from preview with its selected data files: ${dataFilesToInclude.map(f=>f.name).join(', ') || 'none'}`, "info");
            }
            
            await executePythonFileInternal(scriptToRun.fileObject, scriptToRun.content, dataFilesToInclude);
        }

        // Internal function to handle actual execution, called by both run button types
        async function executePythonFileInternal(pyFileObject, scriptContent, dataFilesToInclude) {
            log(`Executing ${pyFileObject.name} with ${dataFilesToInclude.length} data file(s)`);

            try {
                const result = await runPythonScript(scriptContent, {}, dataFilesToInclude);
                
                if (result.status === "complete") {
                    if (result.result) {
                        log(`Result from ${pyFileObject.name}: ${result.result}`);
                    }
                    
                    if (result.modifiedFiles && result.modifiedFiles.length > 0) {
                        handleModifiedFiles(result.modifiedFiles);
                    }
                    // The old includedForRun logic is removed.
                }
            } catch (error) {
                log(`Failed to execute ${pyFileObject.name}: ${error}`, 'error');
            }
        }


        // Select a file for preview
        function selectFile(file) {
            selectedFile = { file };
            
            // Update UI for selected file
            document.querySelectorAll('.file-row').forEach(row => {
                row.classList.remove('active');
            });
            
            // Find the file row and mark it as active
            const fileRows = document.querySelectorAll('.file-row');
            for (let row of fileRows) {
                if (row.textContent.includes(file.name)) {
                    row.classList.add('active');
                    break;
                }
            }
            
            // Preview file
            previewFile(file);
        }

        // Preview parquet file using JavaScript hyparquet
        async function previewParquetFile(file) {
            log(`Loading parquet preview for ${file.name}...`);
            
            // Create loading indicator
            const loadingDiv = document.createElement('div');
            loadingDiv.textContent = 'Loading parquet file...';
            loadingDiv.style.padding = '20px';
            previewPanel.appendChild(loadingDiv);
            
            try {
                // Load hyparquet from CDN
                const { parquetReadObjects, parquetMetadataAsync, parquetSchema } = 
                    await import('https://cdn.jsdelivr.net/npm/hyparquet/src/hyparquet.min.js');
                
                // Read file as ArrayBuffer
                const buffer = await file.arrayBuffer();
                
                // Get file metadata first
                const metadata = await parquetMetadataAsync(buffer);
                const schema = parquetSchema(metadata);
                
                // Get number of rows and column names
                const numRows = Number(metadata.num_rows);
                const columnNames = schema.children.map(e => e.element.name);
                
                // Preview max 100 rows
                const previewRows = 100;
                const data = await parquetReadObjects({
                    file: buffer,
                    columns: columnNames,
                    rowStart: 0,
                    rowEnd: Math.min(previewRows, numRows)
                });
                
                // Remove loading indicator
                loadingDiv.remove();
                
                // Create table container
                const tableContainer = document.createElement('div');
                tableContainer.style.overflowX = 'auto';
                tableContainer.style.maxHeight = '500px';
                tableContainer.style.minHeight = '200px'; // Minimum height for ~5 rows
                tableContainer.style.overflowY = 'auto';
                
                // Create HTML table
                const table = document.createElement('table');
                table.className = 'parquet-table';
                table.style.width = '100%';
                
                // Create header
                const thead = document.createElement('thead');
                const headerRow = document.createElement('tr');
                
                // Add column headers
                columnNames.forEach(column => {
                    const th = document.createElement('th');
                    th.textContent = column;
                    headerRow.appendChild(th);
                });
                
                thead.appendChild(headerRow);
                table.appendChild(thead);
                
                // Create table body
                const tbody = document.createElement('tbody');
                
                // Add data rows
                data.forEach(row => {
                    const tr = document.createElement('tr');
                    
                    // Add cells for each column
                    columnNames.forEach(column => {
                        const td = document.createElement('td');
                        const value = row[column];
                        td.textContent = value !== null && value !== undefined ? value.toString() : 'null';
                        tr.appendChild(td);
                    });
                    
                    tbody.appendChild(tr);
                });
                
                table.appendChild(tbody);
                tableContainer.appendChild(table);
                previewPanel.appendChild(tableContainer);
                
                // Show metadata
                const metadataDiv = document.createElement('div');
                metadataDiv.style.marginTop = '15px';
                metadataDiv.style.fontSize = '0.9rem';
                metadataDiv.style.color = '#666';
                
                // Extract schema types for display
                const schemaInfo = columnNames.map(name => {
                    const child = schema.children.find(c => c.element.name === name);
                    return `${name}: ${child ? child.element.type : 'unknown'}`;
                }).join('\n');
                
                metadataDiv.innerHTML = `
                    <div style="margin-bottom: 10px;"><strong>Parquet File Info:</strong></div>
                    <div><strong>Rows:</strong> ${numRows}</div>
                    <div><strong>Columns:</strong> ${columnNames.length}</div>
                    <div><strong>Preview:</strong> Showing ${Math.min(previewRows, numRows)} of ${numRows} rows</div>
                    <div style="margin-top: 10px;"><strong>Schema:</strong></div>
                    <pre style="font-size: 0.8rem; margin-top: 5px;">${schemaInfo}</pre>
                `;
                
                previewPanel.appendChild(metadataDiv);
                
                log(`Parquet file loaded: ${columnNames.length} columns, ${numRows} rows`, 'success');
                
            } catch (error) {
                loadingDiv.remove();
                previewPanel.innerHTML += `<div class="error">Error reading parquet file: ${error.message}</div>`;
                log(`Error reading parquet file: ${error.message}`, 'error');
            }
        }
        
        // Preview HTML file in an iframe
        function previewHtmlFile(content) {
            // Create a container for the iframe
            const iframeContainer = document.createElement('div');
            iframeContainer.style.width = '100%';
            iframeContainer.style.height = '100%'; // Changed from '500px'
            iframeContainer.style.border = '1px solid #ddd';
            iframeContainer.style.borderRadius = '4px';
            iframeContainer.style.overflow = 'hidden';
            iframeContainer.style.flexGrow = '1'; // Added to fill flex container
            
            // Create the iframe
            const iframe = document.createElement('iframe');
            iframe.style.width = '100%';
            iframe.style.height = '100%';
            iframe.style.border = 'none';
            iframe.sandbox = 'allow-same-origin allow-scripts'; // Restrict capabilities for security, added allow-scripts
            
            // Append the iframe to the container
            iframeContainer.appendChild(iframe);
            previewPanel.appendChild(iframeContainer);
            
            // Set the iframe content
            setTimeout(() => {
                const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                iframeDoc.open();
                iframeDoc.write(content);
                iframeDoc.close();
            }, 0);
        }
        
        // Preview file content
        function previewFile(file) {
            previewPanel.innerHTML = ''; // Clear preview panel
            
            // Create preview header
            const header = document.createElement('div');
            header.style.padding = '0 0 15px 0';
            header.style.borderBottom = '1px solid #eee';
            header.style.marginBottom = '15px';
            
            // For Python files, add a Run button
            let runButtonHtml = ''; // Renamed variable to avoid conflict
            if (file.isPython) {
                // Check if this python file is in our pythonScripts list to ensure it's runnable
                const isRunnablePython = pythonScripts.some(ps => ps.name === file.name);
                if (isRunnablePython) {
                    runButtonHtml = `<button id="runPreviewedFile" class="run-button" style="float: right;">Run Script</button>`;
                } else if (allFiles.some(f => f.name === file.name && f.isPython)) {
                     // It's a .py file in the data list, not the python script list. Don't show run button.
                     log(`Note: ${file.name} is a Python file in the data list. To run, drop it in the Python Scripts area.`, 'info');
                }
            }
            
            header.innerHTML = `<strong>${file.name}</strong> (${(file.size / 1024).toFixed(2)} KB)${runButtonHtml}`;
            previewPanel.appendChild(header);
            
            // Add run button event listener
            if (file.isPython && document.getElementById('runPreviewedFile')) {
                document.getElementById('runPreviewedFile').addEventListener('click', () => {
                    executePythonFile(file); // file here is the File object being previewed
                });
            }
            
            const ext = file.name.split('.').pop().toLowerCase();
            
            // Handle different file types
            if (ext === 'parquet') {
                // For parquet files, use pyodide with hyparquet to load and display
                previewParquetFile(file);
            } else if (ext === 'html') {
                // For HTML files, read as text and display in an iframe
                const fileReader = new FileReader();
                fileReader.onload = function(e) {
                    previewHtmlFile(e.target.result);
                };
                fileReader.onerror = function() {
                    previewPanel.innerHTML += '<div>Error reading HTML file.</div>';
                    log(`Error reading file: ${file.name}`, 'error');
                };
                fileReader.readAsText(file);
            } else if (ext === 'py' || ext === 'txt' || ext === 'json' || ext === 'csv') {
                // For text files, read and display as text
                const fileReader = new FileReader();
                fileReader.onload = function(e) {
                    const codePreview = document.createElement('pre');
                    codePreview.className = 'code-preview';
                    codePreview.textContent = e.target.result;
                    previewPanel.appendChild(codePreview);
                };
                fileReader.onerror = function() {
                    previewPanel.innerHTML += '<div>Error reading file.</div>';
                    log(`Error reading file: ${file.name}`, 'error');
                };
                fileReader.readAsText(file);
            } else {
                previewPanel.innerHTML += '<div>No preview available for this file type.</div>';
            }
            
            log(`Previewing: ${file.name}`);
        }

        // Setup drop zone
        function setupDropZone(dropZoneElement, zoneId) { // Added zoneId
            // Handle drag over
            dropZoneElement.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZoneElement.classList.add('active');
            });
            
            // Handle drag leave
            dropZoneElement.addEventListener('dragleave', () => {
                dropZoneElement.classList.remove('active');
            });
            
            // Handle drop
            dropZoneElement.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZoneElement.classList.remove('active');
                handleFileSelect(e.dataTransfer.files, zoneId); // Pass zoneId
            });
        }

        // Initialize
        function init() {
            setupDropZone(pythonDropZone, 'pythonDropZone'); // Setup for Python zone
            setupDropZone(dataFilesDropZone, 'dataFilesDropZone'); // Setup for Data files zone
            log('App initialized and ready');
            log('Drag and drop Python files to the left, data files to the middle.');
        }

        // Start the app
        init();
    </script>
</body>
</html>
