<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python Browser Runner</title>
    <style>
        :root {
            --primary-bg: #ffffff;
            --panel-bg: #f9f9f9;
            --border-color: #e0e0e0;
            --accent-color: #3498db;
            --text-color: #333333;
            --secondary-text: #666666;
            --terminal-bg: #2d3436;
            --terminal-text: #ecf0f1;
            --drop-zone-hover: rgba(52, 152, 219, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        }

        body {
            background-color: var(--primary-bg);
            color: var(--text-color);
            height: 100vh;
            padding: 20px;
        }

        .container {
            display: grid;
            grid-template-columns: 2fr 3fr;
            grid-template-rows: 2fr 1fr;
            grid-template-areas:
                "left right"
                "terminal terminal";
            gap: 16px;
            height: calc(100vh - 40px);
        }

        .drop-zone {
            background-color: var(--panel-bg);
            border: 2px dashed #777777;
            border-radius: 8px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            transition: all 0.3s ease;
            overflow: auto;
        }
        
        .drop-zone #pythonInstructions,
        .drop-zone #dataInstructions {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            height: 100%;
        }

        .drop-zone:hover {
            background-color: var(--drop-zone-hover);
        }

        .drop-zone.active {
            border-color: var(--accent-color);
            background-color: var(--drop-zone-hover);
        }

        .drop-zone p {
            margin-bottom: 8px;
            font-weight: 500;
        }

        .sub-text {
            font-size: 0.8rem;
            color: var(--secondary-text);
        }

        .files-drop {
            grid-area: left;
        }

        .preview-panel {
            grid-area: right;
            background-color: var(--panel-bg);
            border-radius: 8px;
            padding: 20px;
            overflow: auto;
            display: flex;
            flex-direction: column;
            border: 2px solid #777777;
        }

        .preview-panel .empty-state {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100%;
            color: var(--secondary-text);
        }

        .terminal {
            grid-area: terminal;
            background-color: var(--terminal-bg);
            border-radius: 8px;
            color: var(--terminal-text);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .terminal-header {
            padding: 8px 16px;
            background-color: rgba(255, 255, 255, 0.05);
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .terminal-header button {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            color: var(--terminal-text);
            padding: 2px 8px;
            cursor: pointer;
            font-size: 0.8rem;
        }

        .terminal-header button:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .terminal-content {
            padding: 16px;
            overflow-y: auto;
            flex-grow: 1;
            font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.4;
            white-space: pre-wrap;
        }

        .file-list {
            list-style: none;
            width: 100%;
            margin-top: 10px;
        }

        .file-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
            font-size: 0.9rem;
        }

        .file-table th {
            text-align: left;
            padding: 6px 8px;
            border-bottom: 1px solid var(--border-color);
            font-weight: 500;
            color: var(--secondary-text);
        }
        
        /* Action buttons styling */
        .action-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .btn {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .btn-run {
            background-color: var(--accent-color);
            color: white;
        }
        
        .btn-run:hover:not(:disabled) {
            background-color: #2980b9;
        }
        
        .btn-remove {
            background-color: #e74c3c;
            color: white;
        }
        
        .btn-remove:hover:not(:disabled) {
            background-color: #c0392b;
        }
        
        .btn-download {
            background-color: #27ae60;
            color: white;
        }
        
        .btn-download:hover:not(:disabled) {
            background-color: #219651;
        }
        
        .btn-include {
            background-color: #8e44ad;
            color: white;
        }
        
        .btn-include:hover:not(:disabled) {
            background-color: #7d3c98;
        }
        
        /* Badge for included files */
        .included-badge {
            display: inline-block;
            background-color: #8e44ad;
            color: white;
            font-size: 0.7rem;
            padding: 2px 6px;
            border-radius: 10px;
            margin-left: 6px;
            vertical-align: middle;
        }
        
        /* Sortable table headers */
        .sortable {
            cursor: pointer;
            position: relative;
            padding-right: 18px !important;
        }
        
        .sortable:after {
            content: "↑↓";
            font-size: 0.7em;
            position: absolute;
            right: 6px;
            opacity: 0.3;
        }
        
        .sortable.sort-active:after {
            opacity: 1;
        }
        
        .sortable.sort-asc:after {
            content: "↑";
        }
        
        .sortable.sort-desc:after {
            content: "↓";
        }

        .file-table td {
            padding: 8px;
            border-bottom: 1px solid var(--border-color);
        }

        .file-row {
            cursor: pointer;
        }

        .file-row:hover {
            background-color: rgba(0, 0, 0, 0.05);
        }

        .file-row.active {
            background-color: var(--accent-color);
            color: white;
        }
        
        .file-row.active td {
            border-bottom-color: var(--accent-color);
        }

        .file-icon {
            margin-right: 4px;
            font-size: 1.1rem;
        }
        
        .file-checkbox {
            cursor: pointer;
            width: 16px;
            height: 16px;
        }

        .file-preview {
            width: 100%;
            height: 100%;
            overflow: auto;
            text-align: left;
        }

        .code-preview {
            padding: 16px;
            font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.4;
            background-color: #f5f5f5;
            border-radius: 4px;
            white-space: pre;
            overflow-x: auto;
        }

        .run-button {
            background-color: var(--accent-color);
            color: white;
            border: none;
            border-radius: 4px;
            padding: 6px 12px;
            margin-top: 12px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background-color 0.2s;
        }

        .run-button:hover {
            background-color: #2980b9;
        }

        .run-button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }
        
        /* Parquet table styling */
        .parquet-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9rem;
        }
        
        .parquet-table th {
            background-color: #f5f5f5;
            padding: 8px 12px;
            text-align: left;
            font-weight: 600;
            border-bottom: 2px solid #ddd;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        
        .parquet-table td {
            padding: 8px 12px;
            border-bottom: 1px solid #eee;
            white-space: nowrap;
            max-width: 300px;
            overflow: hidden;
            text-overflow: ellipsis;
            height: 36px; /* Fixed height for table rows */
            line-height: 20px; /* Line height for better text display */
        }
        
        .parquet-table tr:hover td {
            background-color: rgba(0, 0, 0, 0.02);
        }
        
        /* Error message styling */
        .error {
            color: #e74c3c;
            padding: 12px;
            background-color: #fdf1f0;
            border-left: 4px solid #e74c3c;
            margin: 10px 0;
            border-radius: 0 4px 4px 0;
        }

        /* For responsiveness */
        @media (max-width: 768px) {
            .container {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto 1fr;
                grid-template-areas:
                    "left-top"
                    "left-middle"
                    "right"
                    "terminal";
                height: auto;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="drop-zone files-drop" id="filesDropZone">
            <div id="filesInstructions">
                <p>Drag and Drop Files Here</p>
                <p class="sub-text">Python files (.py) and data files (.csv, .parquet, .json, etc.)</p>
            </div>
            <div id="filesList" class="file-list"></div>
        </div>
        
        <div class="preview-panel" id="previewPanel">
            <div class="empty-state">Select a File to Preview</div>
        </div>
        
        <div class="terminal" id="terminal">
            <div class="terminal-header">
                <span>Python Terminal Output</span>
                <button id="clearTerminal">Clear</button>
            </div>
            <div class="terminal-content" id="terminalContent"></div>
        </div>
    </div>

    <!-- Web Worker Blob URLs will be stored here -->
    <script id="webworker" type="text/javascript">
        // This will be converted to a Blob URL and used to create the worker
        // webworker.js
        importScripts("https://cdn.jsdelivr.net/pyodide/v0.27.5/full/pyodide.js");

        let pyodide;
        
        async function loadPyodideAndPackages() {
            self.pyodide = await loadPyodide();
            return self.pyodide;
        }
        
        // Start loading pyodide when the worker starts
        let pyodideReadyPromise = loadPyodideAndPackages();

        self.onmessage = async function(event) {
            // Make sure pyodide is ready
            self.pyodide = await pyodideReadyPromise;
            
            const { id, python, context, files } = event.data;
            
            // Create a status update function to send progress back to main thread
            function sendStatus(status) {
                self.postMessage({ id, status });
            }
            
            try {
                sendStatus("Loading packages...");
                await self.pyodide.loadPackagesFromImports(python);
                
                // Create the data directory for files
                sendStatus("Setting up filesystem...");
                self.pyodide.runPython(`
                    import os
                    if not os.path.exists('/home/pyodide/data'):
                        os.makedirs('/home/pyodide/data')
                `);
                
                // Add any files to the virtual filesystem
                if (files && files.length > 0) {
                    sendStatus("Loading files into filesystem...");
                    
                    // Write each file to the virtual filesystem
                    for (const file of files) {
                        const path = `/home/pyodide/data/${file.name}`;
                        self.pyodide.FS.writeFile(path, new Uint8Array(file.data));
                    }
                }
                
                // Set up the context
                sendStatus("Preparing context...");
                const globals = self.pyodide.toPy(context || {});
                
                // Add utility functions to the context
                self.pyodide.runPython(`
                    import sys
                    import os
                    
                    # Set up data directory in path
                    data_dir = '/home/pyodide/data'
                    sys.path.append(data_dir)
                    
                    # Set current working directory to data directory
                    # This ensures all relative file operations happen in our data directory
                    os.chdir(data_dir)
                    
                    # Redirect stdout and stderr to capture output
                    import io
                    
                    class OutputCollector:
                        def __init__(self):
                            self.value = ""
                        
                        def write(self, text):
                            self.value += text
                            return len(text)
                        
                        def flush(self):
                            pass
                    
                    stdout_collector = OutputCollector()
                    stderr_collector = OutputCollector()
                    
                    old_stdout = sys.stdout
                    old_stderr = sys.stderr
                    
                    sys.stdout = stdout_collector
                    sys.stderr = stderr_collector
                `);
                
                // Run the Python code
                sendStatus("Running Python code...");
                const output = await self.pyodide.runPythonAsync(python, { globals });
                
                // Get captured stdout and stderr
                const stdout = self.pyodide.runPython("stdout_collector.value");
                const stderr = self.pyodide.runPython("stderr_collector.value");
                
                // Reset stdout and stderr
                self.pyodide.runPython(`
                    sys.stdout = old_stdout
                    sys.stderr = old_stderr
                `);
                
                // Collect all files from the virtual filesystem
                sendStatus("Collecting modified files...");
                const modifiedFiles = [];
                
                try {
                    // Make sure the data directory exists (it should, but double-check)
                    self.pyodide.runPython(`
                        import os
                        if not os.path.exists('/home/pyodide/data'):
                            os.makedirs('/home/pyodide/data')
                    `);
                    
                    // Get the list of files in the data directory
                    const dataFiles = self.pyodide.FS.readdir('/home/pyodide/data');
                    
                    // Filter out special entries . and ..
                    const regularFiles = dataFiles.filter(name => name !== '.' && name !== '..');
                    
                    sendStatus(`Found ${regularFiles.length} files to collect`);
                    
                    // Read each file and convert to transferable format
                    for (const fileName of regularFiles) {
                        try {
                            const path = `/home/pyodide/data/${fileName}`;
                            const content = self.pyodide.FS.readFile(path, { encoding: 'binary' });
                            
                            modifiedFiles.push({
                                name: fileName,
                                data: content
                            });
                            
                            sendStatus(`Collected file: ${fileName}`);
                        } catch (fileError) {
                            console.error(`Error reading file ${fileName}:`, fileError);
                            sendStatus(`Error collecting file: ${fileName}`);
                        }
                    }
                } catch (fsError) {
                    console.error("Error reading filesystem:", fsError);
                    sendStatus(`Error accessing filesystem: ${fsError.message}`);
                }
                
                // Send back results with modified files
                self.postMessage({
                    id,
                    status: "complete", 
                    result: output,
                    stdout,
                    stderr,
                    modifiedFiles: modifiedFiles
                });
                
            } catch (error) {
                // When there's an error, we should still try to get stderr if possible
                let stderr = "";
                try {
                    stderr = self.pyodide.runPython("stderr_collector.value");
                } catch (e) {
                    // If we can't get stderr from the collector, just use the error message
                    stderr = error.message || "Unknown error";
                }
                
                self.postMessage({
                    id, 
                    status: "error",
                    error: error.message,
                    stderr: stderr
                });
            }
        };
    </script>

    <script>
        // Store files
        const allFiles = [];
        let selectedFile = null;
        
        // Array to store files included for run
        // This is used by the "Include in Run" feature to track files that should be
        // available to all Python executions until cleared or until after execution
        const includedForRun = [];
        
        // Map of active workers, keyed by script name
        const activeWorkers = {};

        // DOM Elements
        const filesDropZone = document.getElementById('filesDropZone');
        const filesList = document.getElementById('filesList');
        const previewPanel = document.getElementById('previewPanel');
        const terminalContent = document.getElementById('terminalContent');
        const clearTerminalBtn = document.getElementById('clearTerminal');

        // Create web worker from inline script
        function createWorker() {
            const workerScript = document.getElementById('webworker').textContent;
            const blob = new Blob([workerScript], { type: 'application/javascript' });
            const workerUrl = URL.createObjectURL(blob);
            return new Worker(workerUrl);
        }

        // Log to terminal
        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logElement = document.createElement('div');
            logElement.className = `log-entry ${type}`;
            logElement.innerHTML = `[${timestamp}] ${message}`;
            terminalContent.appendChild(logElement);
            terminalContent.scrollTop = terminalContent.scrollHeight;
            
            // Add styling for different log types if it doesn't exist
            if (!document.getElementById('log-styles')) {
                const styleEl = document.createElement('style');
                styleEl.id = 'log-styles';
                styleEl.textContent = `
                    .log-entry.error { color: #e74c3c; }
                    .log-entry.warning { color: #f39c12; }
                    .log-entry.success { color: #2ecc71; }
                `;
                document.head.appendChild(styleEl);
            }
        }

        // Clear terminal
        clearTerminalBtn.addEventListener('click', () => {
            terminalContent.innerHTML = '';
            log('Terminal cleared');
        });

        // Function to get a promise and its resolver
        function getPromiseAndResolve() {
            let resolve;
            let promise = new Promise((res) => {
                resolve = res;
            });
            return { promise, resolve };
        }

        // Unique ID generation for messages
        let lastId = 1;
        function getId() {
            return lastId++;
        }

        // Run a Python script in a worker
        async function runPythonScript(scriptContent, context = {}, additionalFiles = []) {
            // Create a new worker for each script
            const worker = createWorker();
            
            // Create a new promise to wait for the result
            const { promise, resolve } = getPromiseAndResolve();
            const scriptId = getId();
            
            // Set up message handler
            worker.onmessage = function(event) {
                const data = event.data;
                
                // Check if this is a response to our request
                if (data.id === scriptId) {
                    if (data.status === "complete") {
                        // Script completed successfully
                        log(`Script execution completed`, 'success');
                        
                        // Log stdout and stderr
                        if (data.stdout) {
                            log(`Python stdout:\n${data.stdout}`);
                        }
                        
                        if (data.stderr && data.stderr.trim()) {
                            log(`Python stderr:\n${data.stderr}`, 'error');
                        }
                        
                        resolve(data);
                    } else if (data.status === "error") {
                        // Script execution failed
                        log(`Python Error: ${data.error}`, 'error');
                        
                        // Log stderr if available
                        if (data.stderr && data.stderr.trim()) {
                            log(`Python stderr:\n${data.stderr}`, 'error');
                        }
                        
                        resolve(data);
                    } else {
                        // Status update
                        log(`Pyodide: ${data.status}`);
                    }
                }
            };
            
            // Convert file contents to ArrayBuffer for file transfer
            const fileData = await Promise.all(additionalFiles.map(async (file) => {
                return {
                    name: file.name,
                    data: await file.arrayBuffer()
                };
            }));
            
            // Send the script to the worker
            log(`Starting Python execution...`);
            worker.postMessage({
                id: scriptId,
                python: scriptContent,
                context,
                files: fileData
            });
            
            return promise;
        }

        // Handle file selection
        function handleFileSelect(files) {
            Array.from(files).forEach(file => {
                // Check if file already exists
                if (!allFiles.some(f => f.name === file.name)) {
                    // Add file type property
                    const fileObj = file;
                    fileObj.isPython = file.name.toLowerCase().endsWith('.py');
                    
                    allFiles.push(fileObj);
                    log(`Added file: ${file.name}`);
                } else {
                    log(`File ${file.name} already exists`, 'warning');
                }
            });
            
            updateFileList();
        }

        // Update file list display
        function updateFileList() {
            const instructionsElement = document.getElementById('filesInstructions');
            
            // Hide instructions if files exist
            if (allFiles.length > 0) {
                instructionsElement.style.display = 'none';
            } else {
                instructionsElement.style.display = 'block';
            }
            
            filesList.innerHTML = '';
            
            // Add action buttons if files exist
            if (allFiles.length > 0) {
                const actionButtons = document.createElement('div');
                actionButtons.className = 'action-buttons';
                actionButtons.innerHTML = `
                    <button id="runSelectedFiles" class="btn btn-run" disabled>Run</button>
                    <button id="includeInRunFiles" class="btn btn-include" disabled>Include in Run</button>
                    <button id="downloadSelectedFiles" class="btn btn-download" disabled>Download</button>
                    <button id="removeSelectedFiles" class="btn btn-remove" disabled>Delete</button>
                `;
                
                // Create a hidden div element to hold the includedFilesStatus ID
                // This way we still have the element but it's not visible
                const includedFilesStatus = document.createElement('div');
                includedFilesStatus.id = 'includedFilesStatus';
                includedFilesStatus.style.display = 'none';
                
                filesList.appendChild(includedFilesStatus);
                filesList.appendChild(actionButtons);
            }
            
            if (allFiles.length > 0) {
                // Create table
                const table = document.createElement('table');
                table.className = 'file-table';
                
                // Create table header with sortable columns
                const thead = document.createElement('thead');
                thead.innerHTML = `
                    <tr>
                        <th><input type="checkbox" id="selectAllFiles"></th>
                        <th class="sortable sort-active sort-asc" data-sort="name">Name</th>
                        <th class="sortable" data-sort="size">Size</th>
                        <th class="sortable" data-sort="date">Last Modified</th>
                    </tr>
                `;
                table.appendChild(thead);
                
                // Create table body
                const tbody = document.createElement('tbody');
                allFiles.forEach(file => {
                    const tr = document.createElement('tr');
                    tr.className = 'file-row';
                    
                    // Format date
                    const date = new Date(file.lastModified);
                    const dateString = date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
                    
                    // Calculate size
                    const sizeString = file.size < 1024 
                        ? file.size + ' B'
                        : file.size < 1024 * 1024
                            ? (file.size / 1024).toFixed(1) + ' KB'
                            : (file.size / (1024 * 1024)).toFixed(1) + ' MB';
                    
                    // Store size value for sorting
                    const sizeBytes = file.size;
                    
                    // Store date for sorting
                    const dateValue = file.lastModified;
                    
                    tr.innerHTML = `
                        <td><input type="checkbox" class="file-checkbox" data-filename="${file.name}"></td>
                        <td data-value="${file.name}"><span class="file-icon">📄</span>${file.name}</td>
                        <td data-value="${sizeBytes}">${sizeString}</td>
                        <td data-value="${dateValue}">${dateString}</td>
                    `;
                    
                    // Add data attributes for sorting
                    tr.dataset.name = file.name.toLowerCase();
                    tr.dataset.size = String(file.size);
                    tr.dataset.date = String(file.lastModified);
                    
                    // Add badge if file is included for run
                    if (includedForRun.some(f => f.name === file.name)) {
                        const nameCell = tr.querySelector('td:nth-child(2)');
                        const badge = document.createElement('span');
                        badge.className = 'included-badge';
                        badge.textContent = 'included';
                        nameCell.appendChild(badge);
                    }
                    
                    // Add click handler for row
                    tr.addEventListener('click', (e) => {
                        // Don't trigger row selection when checkbox or button is clicked
                        if (e.target.type !== 'checkbox' && e.target.tagName !== 'BUTTON') {
                            selectFile(file);
                        }
                    });
                    
                    tbody.appendChild(tr);
                });
                
                table.appendChild(tbody);
                filesList.appendChild(table);
                
                // Add select all functionality
                const selectAllCheckbox = document.getElementById('selectAllFiles');
                selectAllCheckbox.addEventListener('change', () => {
                    const checkboxes = filesList.querySelectorAll('.file-checkbox');
                    checkboxes.forEach(checkbox => {
                        checkbox.checked = selectAllCheckbox.checked;
                    });
                    // Update action buttons state
                    updateActionButtonsState();
                });
                
                // Function to update action buttons state based on selections
                function updateActionButtonsState() {
                    const runButton = document.getElementById('runSelectedFiles');
                    const downloadButton = document.getElementById('downloadSelectedFiles');
                    const removeButton = document.getElementById('removeSelectedFiles');
                    const includeButton = document.getElementById('includeInRunFiles');
                    const checkedBoxes = filesList.querySelectorAll('.file-checkbox:checked');
                    const hasSelection = checkedBoxes.length > 0;
                    
                    // Enable/disable remove and download buttons based on any selections
                    removeButton.disabled = !hasSelection;
                    downloadButton.disabled = !hasSelection;
                    
                    // Enable/disable include button based on any selection
                    includeButton.disabled = !hasSelection;
                    
                    // Enable/disable run button based on if only Python files are selected
                    let onlyPythonSelected = true;
                    
                    if (hasSelection) {
                        // Check if all selected files are Python files
                        checkedBoxes.forEach(checkbox => {
                            const filename = checkbox.dataset.filename;
                            const file = allFiles.find(f => f.name === filename);
                            if (!file || !file.isPython) {
                                onlyPythonSelected = false;
                            }
                        });
                    } else {
                        onlyPythonSelected = false; // No selection means run is disabled
                    }
                    
                    runButton.disabled = !onlyPythonSelected;
                }
                
                // Add sorting functionality to the table headers
                const sortableHeaders = thead.querySelectorAll('.sortable');
                sortableHeaders.forEach(header => {
                    header.addEventListener('click', () => {
                        const sortBy = header.dataset.sort;
                        const isAsc = header.classList.contains('sort-asc');
                        
                        // Reset all headers
                        sortableHeaders.forEach(h => {
                            h.classList.remove('sort-active', 'sort-asc', 'sort-desc');
                        });
                        
                        // Set active sort
                        header.classList.add('sort-active');
                        if (isAsc) {
                            header.classList.add('sort-desc');
                        } else {
                            header.classList.add('sort-asc');
                        }
                        
                        // Get all rows and convert to array for sorting
                        const rows = Array.from(tbody.querySelectorAll('tr'));
                        
                        // Sort the rows based on the selected column
                        rows.sort((a, b) => {
                            let aValue = a.dataset[sortBy];
                            let bValue = b.dataset[sortBy];
                            
                            // Special handling for size and date, which are numbers
                            if (sortBy === 'size' || sortBy === 'date') {
                                aValue = Number(aValue);
                                bValue = Number(bValue);
                            }
                            
                            if (aValue < bValue) return isAsc ? -1 : 1;
                            if (aValue > bValue) return isAsc ? 1 : -1;
                            return 0;
                        });
                        
                        // Clear and re-append sorted rows
                        tbody.innerHTML = '';
                        rows.forEach(row => tbody.appendChild(row));
                    });
                });
                
                // Add event listeners to all checkboxes to update action buttons state
                const checkboxes = filesList.querySelectorAll('.file-checkbox');
                checkboxes.forEach(checkbox => {
                    checkbox.addEventListener('change', updateActionButtonsState);
                });
                
                // No more individual run buttons in the table rows
                
                // Add run selected files functionality
                const runSelectedButton = document.getElementById('runSelectedFiles');
                runSelectedButton.addEventListener('click', async () => {
                    const selectedCheckboxes = filesList.querySelectorAll('.file-checkbox:checked');
                    if (selectedCheckboxes.length === 0) return;
                    
                    // Get selected Python files
                    const selectedPythonFiles = [];
                    selectedCheckboxes.forEach(checkbox => {
                        const filename = checkbox.dataset.filename;
                        const file = allFiles.find(f => f.name === filename);
                        if (file && file.isPython) {
                            selectedPythonFiles.push(file);
                        }
                    });
                    
                    // Execute each Python file
                    if (selectedPythonFiles.length > 0) {
                        log(`Executing ${selectedPythonFiles.length} Python file(s)...`);
                        for (const file of selectedPythonFiles) {
                            await executePythonFile(file);
                        }
                    }
                });
                
                // Add include in run button functionality
                const includeButton = document.getElementById('includeInRunFiles');
                includeButton.addEventListener('click', () => {
                    const selectedCheckboxes = filesList.querySelectorAll('.file-checkbox:checked');
                    if (selectedCheckboxes.length === 0) return;
                    
                    // Get selected files
                    selectedCheckboxes.forEach(checkbox => {
                        const filename = checkbox.dataset.filename;
                        const file = allFiles.find(f => f.name === filename);
                        if (file) {
                            // Check if file is already included
                            if (!includedForRun.some(f => f.name === file.name)) {
                                includedForRun.push(file);
                                log(`Included file for run: ${file.name}`, 'success');
                            }
                        }
                    });
                    
                    // We don't need to update the status display anymore as it's hidden
                    
                    // Uncheck all checkboxes
                    selectedCheckboxes.forEach(checkbox => {
                        checkbox.checked = false;
                    });
                    
                    // Uncheck "select all" checkbox if it exists
                    const selectAllCheckbox = document.getElementById('selectAllFiles');
                    if (selectAllCheckbox) {
                        selectAllCheckbox.checked = false;
                    }
                    
                    // Update action buttons state
                    updateActionButtonsState();
                    
                    // Update the file list to show the included badges
                    updateFileList();
                });
                
                // Add download selected files functionality
                const downloadButton = document.getElementById('downloadSelectedFiles');
                downloadButton.addEventListener('click', () => {
                    const selectedCheckboxes = filesList.querySelectorAll('.file-checkbox:checked');
                    if (selectedCheckboxes.length === 0) return;
                    
                    // Get selected files
                    const filesForDownload = [];
                    selectedCheckboxes.forEach(checkbox => {
                        const filename = checkbox.dataset.filename;
                        const file = allFiles.find(f => f.name === filename);
                        if (file) {
                            filesForDownload.push(file);
                        }
                    });
                    
                    // Handle downloads based on count
                    if (filesForDownload.length === 1) {
                        // Single file download
                        const file = filesForDownload[0];
                        const downloadUrl = URL.createObjectURL(file);
                        const a = document.createElement('a');
                        a.href = downloadUrl;
                        a.download = file.name;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(downloadUrl);
                        log(`Downloaded file: ${file.name}`, 'success');
                    } else if (filesForDownload.length > 1) {
                        // Multiple files - create a zip file
                        // First, dynamically load JSZip via script tag
                        log('Preparing to download multiple files as zip...', 'info');
                        
                        // Create script element for JSZip
                        const script = document.createElement('script');
                        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
                        script.onload = async () => {
                            try {
                                // JSZip is now available as a global variable
                                const zip = new JSZip();
                                
                                // Add each file to the zip
                                filesForDownload.forEach(file => {
                                    zip.file(file.name, file);
                                });
                                
                                // Generate the zip file
                                const zipContent = await zip.generateAsync({ type: 'blob' });
                                
                                // Create download link
                                const downloadUrl = URL.createObjectURL(zipContent);
                                const a = document.createElement('a');
                                a.href = downloadUrl;
                                a.download = 'files.zip';
                                document.body.appendChild(a);
                                a.click();
                                document.body.removeChild(a);
                                URL.revokeObjectURL(downloadUrl);
                                
                                log(`Downloaded ${filesForDownload.length} files as zip`, 'success');
                            } catch (error) {
                                log(`Error creating zip file: ${error.message}`, 'error');
                                console.error(error);
                            }
                        };
                        
                        script.onerror = () => {
                            log('Failed to load JSZip library. Check your internet connection.', 'error');
                        };
                        
                        // Add script to document to load it
                        document.head.appendChild(script);
                    }
                });
                
                // Add remove selected files functionality
                const removeButton = document.getElementById('removeSelectedFiles');
                removeButton.addEventListener('click', () => {
                    // Get all selected files
                    const selectedCheckboxes = filesList.querySelectorAll('.file-checkbox:checked');
                    if (selectedCheckboxes.length === 0) return;
                    
                    // Get filenames to remove
                    const filenamesToRemove = Array.from(selectedCheckboxes).map(
                        checkbox => checkbox.dataset.filename
                    );
                    
                    // Remove files from allFiles array
                    filenamesToRemove.forEach(filename => {
                        const index = allFiles.findIndex(f => f.name === filename);
                        if (index !== -1) {
                            allFiles.splice(index, 1);
                            log(`Deleted file: ${filename}`, 'warning');
                        }
                    });
                    
                    // If removed file was previewed, clear preview panel
                    if (selectedFile && filenamesToRemove.includes(selectedFile.file.name)) {
                        previewPanel.innerHTML = '<div class="empty-state">Select a File to Preview</div>';
                        selectedFile = null;
                    }
                    
                    // Update file list
                    updateFileList();
                });
            }
        }
        
        // Process modified files returned from Pyodide
        function handleModifiedFiles(modifiedFiles) {
            if (!modifiedFiles || modifiedFiles.length === 0) {
                return;
            }
            
            log(`Processing ${modifiedFiles.length} modified files from Python execution...`, 'info');
            
            // Process each modified file
            modifiedFiles.forEach(modifiedFile => {
                // Create a File object from the binary data
                const blob = new Blob([modifiedFile.data], { type: 'application/octet-stream' });
                const file = new File([blob], modifiedFile.name, { 
                    lastModified: new Date().getTime() 
                });
                
                // Set isPython property
                file.isPython = file.name.toLowerCase().endsWith('.py');
                
                // Check if this file already exists in our files array
                const existingFileIndex = allFiles.findIndex(f => f.name === modifiedFile.name);
                
                if (existingFileIndex >= 0) {
                    // Replace the existing file
                    allFiles[existingFileIndex] = file;
                    log(`Updated file: ${modifiedFile.name}`, 'success');
                } else {
                    // Add as a new file
                    allFiles.push(file);
                    log(`Added new file from Python: ${modifiedFile.name}`, 'success');
                }
            });
            
            // Refresh the file list display
            updateFileList();
        }
        
        // Execute a Python file using a web worker
        async function executePythonFile(file) {
            log(`Preparing to execute ${file.name}...`);
            
            // Read the file content
            const content = await file.text();
            
            // Combine included files and currently selected files
            const dataFilesToInclude = [];
            
            // First add all files that were explicitly included for run
            if (includedForRun.length > 0) {
                log(`Using ${includedForRun.length} previously included files`);
                includedForRun.forEach(includedFile => {
                    if (!dataFilesToInclude.some(f => f.name === includedFile.name)) {
                        dataFilesToInclude.push(includedFile);
                    }
                });
            }
            
            // Then add any currently selected data files (all checked files except Python files)
            const currentlySelectedFiles = [];
            document.querySelectorAll('#filesList .file-checkbox:checked').forEach(checkbox => {
                const filename = checkbox.dataset.filename;
                const dataFile = allFiles.find(f => f.name === filename && !f.isPython);
                if (dataFile && !dataFilesToInclude.some(f => f.name === dataFile.name)) {
                    currentlySelectedFiles.push(dataFile);
                    dataFilesToInclude.push(dataFile);
                }
            });
            
            if (currentlySelectedFiles.length > 0) {
                log(`Including ${currentlySelectedFiles.length} currently selected data files`);
            }
            
            // Run the Python script
            try {
                // Execute the script with all included files
                const result = await runPythonScript(content, {}, dataFilesToInclude);
                
                if (result.status === "complete") {
                    if (result.result) {
                        log(`Result: ${result.result}`);
                    }
                    
                    // Process any modified files returned from Pyodide
                    if (result.modifiedFiles && result.modifiedFiles.length > 0) {
                        handleModifiedFiles(result.modifiedFiles);
                    }
                    
                    // Reset the includedForRun array after execution
                    // Only do this if there were actually included files
                    if (includedForRun.length > 0) {
                        log('Clearing included files after execution', 'info');
                        includedForRun.length = 0;
                        updateFileList(); // Update UI to remove badges
                    }
                }
            } catch (error) {
                log(`Failed to execute ${file.name}: ${error}`, 'error');
            }
        }

        // Select a file for preview
        function selectFile(file) {
            selectedFile = { file };
            
            // Update UI for selected file
            document.querySelectorAll('.file-row').forEach(row => {
                row.classList.remove('active');
            });
            
            // Find the file row and mark it as active
            const fileRows = document.querySelectorAll('.file-row');
            for (let row of fileRows) {
                if (row.textContent.includes(file.name)) {
                    row.classList.add('active');
                    break;
                }
            }
            
            // Preview file
            previewFile(file);
        }

        // Preview parquet file using JavaScript hyparquet
        async function previewParquetFile(file) {
            log(`Loading parquet preview for ${file.name}...`);
            
            // Create loading indicator
            const loadingDiv = document.createElement('div');
            loadingDiv.textContent = 'Loading parquet file...';
            loadingDiv.style.padding = '20px';
            previewPanel.appendChild(loadingDiv);
            
            try {
                // Load hyparquet from CDN
                const { parquetReadObjects, parquetMetadataAsync, parquetSchema } = 
                    await import('https://cdn.jsdelivr.net/npm/hyparquet/src/hyparquet.min.js');
                
                // Read file as ArrayBuffer
                const buffer = await file.arrayBuffer();
                
                // Get file metadata first
                const metadata = await parquetMetadataAsync(buffer);
                const schema = parquetSchema(metadata);
                
                // Get number of rows and column names
                const numRows = Number(metadata.num_rows);
                const columnNames = schema.children.map(e => e.element.name);
                
                // Preview max 100 rows
                const previewRows = 100;
                const data = await parquetReadObjects({
                    file: buffer,
                    columns: columnNames,
                    rowStart: 0,
                    rowEnd: Math.min(previewRows, numRows)
                });
                
                // Remove loading indicator
                loadingDiv.remove();
                
                // Create table container
                const tableContainer = document.createElement('div');
                tableContainer.style.overflowX = 'auto';
                tableContainer.style.maxHeight = '500px';
                tableContainer.style.minHeight = '200px'; // Minimum height for ~5 rows
                tableContainer.style.overflowY = 'auto';
                
                // Create HTML table
                const table = document.createElement('table');
                table.className = 'parquet-table';
                table.style.width = '100%';
                
                // Create header
                const thead = document.createElement('thead');
                const headerRow = document.createElement('tr');
                
                // Add column headers
                columnNames.forEach(column => {
                    const th = document.createElement('th');
                    th.textContent = column;
                    headerRow.appendChild(th);
                });
                
                thead.appendChild(headerRow);
                table.appendChild(thead);
                
                // Create table body
                const tbody = document.createElement('tbody');
                
                // Add data rows
                data.forEach(row => {
                    const tr = document.createElement('tr');
                    
                    // Add cells for each column
                    columnNames.forEach(column => {
                        const td = document.createElement('td');
                        const value = row[column];
                        td.textContent = value !== null && value !== undefined ? value.toString() : 'null';
                        tr.appendChild(td);
                    });
                    
                    tbody.appendChild(tr);
                });
                
                table.appendChild(tbody);
                tableContainer.appendChild(table);
                previewPanel.appendChild(tableContainer);
                
                // Show metadata
                const metadataDiv = document.createElement('div');
                metadataDiv.style.marginTop = '15px';
                metadataDiv.style.fontSize = '0.9rem';
                metadataDiv.style.color = '#666';
                
                // Extract schema types for display
                const schemaInfo = columnNames.map(name => {
                    const child = schema.children.find(c => c.element.name === name);
                    return `${name}: ${child ? child.element.type : 'unknown'}`;
                }).join('\n');
                
                metadataDiv.innerHTML = `
                    <div style="margin-bottom: 10px;"><strong>Parquet File Info:</strong></div>
                    <div><strong>Rows:</strong> ${numRows}</div>
                    <div><strong>Columns:</strong> ${columnNames.length}</div>
                    <div><strong>Preview:</strong> Showing ${Math.min(previewRows, numRows)} of ${numRows} rows</div>
                    <div style="margin-top: 10px;"><strong>Schema:</strong></div>
                    <pre style="font-size: 0.8rem; margin-top: 5px;">${schemaInfo}</pre>
                `;
                
                previewPanel.appendChild(metadataDiv);
                
                log(`Parquet file loaded: ${columnNames.length} columns, ${numRows} rows`, 'success');
                
            } catch (error) {
                loadingDiv.remove();
                previewPanel.innerHTML += `<div class="error">Error reading parquet file: ${error.message}</div>`;
                log(`Error reading parquet file: ${error.message}`, 'error');
            }
        }
        
        // Preview HTML file in an iframe
        function previewHtmlFile(content) {
            // Create a container for the iframe
            const iframeContainer = document.createElement('div');
            iframeContainer.style.width = '100%';
            iframeContainer.style.height = '500px';
            iframeContainer.style.border = '1px solid #ddd';
            iframeContainer.style.borderRadius = '4px';
            iframeContainer.style.overflow = 'hidden';
            
            // Create the iframe
            const iframe = document.createElement('iframe');
            iframe.style.width = '100%';
            iframe.style.height = '100%';
            iframe.style.border = 'none';
            iframe.sandbox = 'allow-same-origin'; // Restrict capabilities for security
            
            // Append the iframe to the container
            iframeContainer.appendChild(iframe);
            previewPanel.appendChild(iframeContainer);
            
            // Set the iframe content
            setTimeout(() => {
                const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                iframeDoc.open();
                iframeDoc.write(content);
                iframeDoc.close();
            }, 0);
        }
        
        // Preview file content
        function previewFile(file) {
            previewPanel.innerHTML = ''; // Clear preview panel
            
            // Create preview header
            const header = document.createElement('div');
            header.style.padding = '0 0 15px 0';
            header.style.borderBottom = '1px solid #eee';
            header.style.marginBottom = '15px';
            
            // For Python files, add a Run button
            let runButton = '';
            if (file.isPython) {
                runButton = `<button id="runPreviewedFile" class="run-button" style="float: right;">Run Script</button>`;
            }
            
            header.innerHTML = `<strong>${file.name}</strong> (${(file.size / 1024).toFixed(2)} KB)${runButton}`;
            previewPanel.appendChild(header);
            
            // Add run button event listener
            if (file.isPython) {
                document.getElementById('runPreviewedFile').addEventListener('click', () => {
                    executePythonFile(file);
                });
            }
            
            const ext = file.name.split('.').pop().toLowerCase();
            
            // Handle different file types
            if (ext === 'parquet') {
                // For parquet files, use pyodide with hyparquet to load and display
                previewParquetFile(file);
            } else if (ext === 'html') {
                // For HTML files, read as text and display in an iframe
                const fileReader = new FileReader();
                fileReader.onload = function(e) {
                    previewHtmlFile(e.target.result);
                };
                fileReader.onerror = function() {
                    previewPanel.innerHTML += '<div>Error reading HTML file.</div>';
                    log(`Error reading file: ${file.name}`, 'error');
                };
                fileReader.readAsText(file);
            } else if (ext === 'py' || ext === 'txt' || ext === 'json' || ext === 'csv') {
                // For text files, read and display as text
                const fileReader = new FileReader();
                fileReader.onload = function(e) {
                    const codePreview = document.createElement('pre');
                    codePreview.className = 'code-preview';
                    codePreview.textContent = e.target.result;
                    previewPanel.appendChild(codePreview);
                };
                fileReader.onerror = function() {
                    previewPanel.innerHTML += '<div>Error reading file.</div>';
                    log(`Error reading file: ${file.name}`, 'error');
                };
                fileReader.readAsText(file);
            } else {
                previewPanel.innerHTML += '<div>No preview available for this file type.</div>';
            }
            
            log(`Previewing: ${file.name}`);
        }

        // Setup drop zone
        function setupDropZone(dropZone) {
            // Handle drag over
            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.classList.add('active');
            });
            
            // Handle drag leave
            dropZone.addEventListener('dragleave', () => {
                dropZone.classList.remove('active');
            });
            
            // Handle drop
            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.classList.remove('active');
                handleFileSelect(e.dataTransfer.files);
            });
        }

        // Initialize
        function init() {
            setupDropZone(filesDropZone);
            log('App initialized and ready');
            log('Drag and drop Python files to execute them with Pyodide');
        }

        // Start the app
        init();
    </script>
</body>
</html>
