<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BrowserBox - Py & R Runner</title>
    <style>
        /* --- CSS (No changes from previous version) --- */
        :root {
            --primary-bg: #ffffff;
            --panel-bg: #f9f9f9;
            --border-color: #e0e0e0;
            --accent-color: #3498db; /* Blue for Python */
            --r-accent-color: #1e8449; /* Green for R */
            --text-color: #333333;
            --secondary-text: #666666;
            --terminal-bg: #2d3436;
            --terminal-text: #ecf0f1;
            --drop-zone-hover: rgba(52, 152, 219, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        }

        body {
            background-color: var(--primary-bg);
            color: var(--text-color);
            height: 100vh;
            padding: 20px;
        }

        .container {
            display: grid;
            grid-template-columns: 2fr 3fr;
            grid-template-rows: 2fr 1fr;
            grid-template-areas:
                "left right"
                "terminal terminal";
            gap: 16px;
            height: calc(100vh - 40px);
        }

        .drop-zone {
            background-color: var(--panel-bg);
            border: 2px dashed #777777;
            border-radius: 8px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            transition: all 0.3s ease;
            overflow: auto;
        }
        
        .drop-zone #filesInstructions {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            height: 100%;
            cursor: pointer; /* Make instructions area clickable */
        }

        .drop-zone:hover {
            background-color: var(--drop-zone-hover);
        }

        .drop-zone.active {
            border-color: var(--accent-color);
            background-color: var(--drop-zone-hover);
        }

        .drop-zone p {
            margin-bottom: 8px;
            font-weight: 500;
        }

        .sub-text {
            font-size: 0.8rem;
            color: var(--secondary-text);
        }

        .files-drop {
            grid-area: left;
        }

        .preview-panel {
            grid-area: right;
            background-color: var(--panel-bg);
            border-radius: 8px;
            padding: 20px;
            overflow: auto;
            display: flex;
            flex-direction: column;
            border: 2px solid #777777;
        }

        .preview-panel .empty-state {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100%;
            color: var(--secondary-text);
        }

        .terminal {
            grid-area: terminal;
            background-color: var(--terminal-bg);
            border-radius: 8px;
            color: var(--terminal-text);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .terminal-header {
            padding: 8px 16px;
            background-color: rgba(255, 255, 255, 0.05);
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .terminal-header button {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            color: var(--terminal-text);
            padding: 2px 8px;
            cursor: pointer;
            font-size: 0.8rem;
        }

        .terminal-header button:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .terminal-content {
            padding: 16px;
            overflow-y: auto;
            flex-grow: 1;
            font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.4;
            white-space: pre-wrap;
        }

        .file-list {
            list-style: none;
            width: 100%;
            margin-top: 10px;
        }

        .file-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
            font-size: 0.9rem;
        }

        .file-table th {
            text-align: left;
            padding: 6px 8px;
            border-bottom: 1px solid var(--border-color);
            font-weight: 500;
            color: var(--secondary-text);
        }
        
        .action-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .btn {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .btn-run {
            background-color: var(--accent-color); /* Default blue for Python */
            color: white;
        }
        
        .btn-run.run-r { /* Specific style for R */
            background-color: var(--r-accent-color);
        }
        
        .btn-run:hover:not(:disabled) {
            filter: brightness(90%); /* Generic hover effect */
        }
        
        .btn-remove {
            background-color: #e74c3c;
            color: white;
        }
        
        .btn-remove:hover:not(:disabled) {
            background-color: #c0392b;
        }
        
        .btn-download {
            background-color: #27ae60;
            color: white;
        }
        
        .btn-download:hover:not(:disabled) {
            background-color: #219651;
        }
        
        .btn-include {
            background-color: #8e44ad;
            color: white;
        }
        
        .btn-include:hover:not(:disabled) {
            background-color: #7d3c98;
        }
        
        .included-badge {
            display: inline-block;
            background-color: #8e44ad;
            color: white;
            font-size: 0.7rem;
            padding: 2px 6px;
            border-radius: 10px;
            margin-left: 6px;
            vertical-align: middle;
        }
        
        .sortable {
            cursor: pointer;
            position: relative;
            padding-right: 18px !important;
        }
        
        .sortable:after {
            content: "‚Üë‚Üì";
            font-size: 0.7em;
            position: absolute;
            right: 6px;
            opacity: 0.3;
        }
        
        .sortable.sort-active:after {
            opacity: 1;
        }
        
        .sortable.sort-asc:after {
            content: "‚Üë";
        }
        
        .sortable.sort-desc:after {
            content: "‚Üì";
        }

        .file-table td {
            padding: 8px;
            border-bottom: 1px solid var(--border-color);
        }

        .file-row {
            cursor: pointer;
        }

        .file-row:hover {
            background-color: rgba(0, 0, 0, 0.05);
        }

        .file-row.active {
            background-color: var(--accent-color);
            color: white;
        }
        .file-row.active.is-r { /* Style for active R row */
             background-color: var(--r-accent-color);
        }
        
        .file-row.active td {
            border-bottom-color: var(--accent-color);
        }
        .file-row.active.is-r td {
             border-bottom-color: var(--r-accent-color);
        }

        .file-icon {
            margin-right: 4px;
            font-size: 1.1rem;
            color: #555; /* Default icon color */
        }
        .file-icon.python { color: var(--accent-color); } /* Python icon color */
        .file-icon.r { color: var(--r-accent-color); }     /* R icon color */
        .file-icon.data { color: #f39c12; } /* Example data icon color */
        
        .file-checkbox {
            cursor: pointer;
            width: 16px;
            height: 16px;
        }

        .file-preview {
            width: 100%;
            height: 100%;
            overflow: auto;
            text-align: left;
        }

        .code-preview {
            padding: 16px;
            font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.4;
            background-color: #f5f5f5;
            border-radius: 4px;
            white-space: pre;
            overflow-x: auto;
        }

        .run-button {
            background-color: var(--accent-color); /* Default Blue */
            color: white;
            border: none;
            border-radius: 4px;
            padding: 6px 12px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background-color 0.2s;
        }
        
        .run-button.run-r { /* R run button color */
             background-color: var(--r-accent-color);
        }

        .run-button:hover:not(:disabled) {
             filter: brightness(90%);
        }

        .run-button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }
        
        .parquet-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9rem;
        }
        .parquet-table th {
            background-color: #f5f5f5;
            padding: 8px 12px;
            text-align: left;
            font-weight: 600;
            border-bottom: 2px solid #ddd;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        .parquet-table td {
            padding: 8px 12px;
            border-bottom: 1px solid #eee;
            white-space: nowrap;
            max-width: 300px;
            overflow: hidden;
            text-overflow: ellipsis;
            height: 36px;
            line-height: 20px;
        }
        .parquet-table tr:hover td {
            background-color: rgba(0, 0, 0, 0.02);
        }
        
        .error {
            color: #e74c3c;
            padding: 12px;
            background-color: #fdf1f0;
            border-left: 4px solid #e74c3c;
            margin: 10px 0;
            border-radius: 0 4px 4px 0;
        }

        /* Log entry styling */
        .log-entry.error { color: #e74c3c; }
        .log-entry.warning { color: #f39c12; }
        .log-entry.success { color: #2ecc71; }
        .log-entry.r { color: #1abc9c; } /* Specific color for R messages */

        @media (max-width: 768px) { 
             .container {
                 grid-template-columns: 1fr;
                 grid-template-rows: auto auto 1fr 1fr; /* Adjusted for smaller screens */
                 grid-template-areas:
                     "left" /* Was left */
                     "right" /* Was right */
                     "terminal" /* Was terminal */
                     ; /* Remove unused areas */
                 height: auto; /* Allow height to adjust */
            }
             .preview-panel {
                min-height: 200px; /* Ensure preview has some height */
            }
             .terminal {
                min-height: 150px; /* Ensure terminal has some height */
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="drop-zone files-drop" id="filesDropZone">
            <div id="filesInstructions">
                <p>Drag & Drop Files or Click Here</p>
                <p class="sub-text">Python (.py), R (.R) scripts and data files (.csv, .parquet, etc.)</p>
            </div>
            <div id="filesList" class="file-list"></div>
        </div>
        
        <div class="preview-panel" id="previewPanel">
            <div class="empty-state">Select a File to Preview</div>
        </div>
        
        <div class="terminal" id="terminal">
            <div class="terminal-header">
                <span>Terminal Output</span>
                <button id="clearTerminal">Clear</button>
            </div>
            <div class="terminal-content" id="terminalContent"></div>
        </div>
    </div>

    <script id="pyodide-webworker" type="text/web-worker">
        // webworker-pyodide.js
        // Uses importScripts, runs as a classic worker
        importScripts("https://cdn.jsdelivr.net/pyodide/v0.27.5/full/pyodide.js");

        let pyodide;
        let pyodideReadyPromise;

        async function loadPyodideAndPackages() {
            if (!pyodide) {
                self.postMessage({ status: 'init', message: 'Loading Pyodide runtime...' });
                pyodide = await loadPyodide();
                self.postMessage({ status: 'init', message: 'Pyodide runtime loaded.' });
            }
            return pyodide;
        }
        
        pyodideReadyPromise = loadPyodideAndPackages(); // Start loading

        self.onmessage = async function(event) {
            const { id, python, files } = event.data;
            
            try {
                self.pyodide = await pyodideReadyPromise;
            } catch (error) {
                 self.postMessage({ id, status: "error", error: `Pyodide initialization failed: ${error.message}` });
                 return;
            }
            
            function sendStatus(status) { self.postMessage({ id, status }); }
            
            let stdout = "";
            let stderr = "";
            const dataDir = '/home/pyodide/data'; // Define dataDir early
            
            try {
                sendStatus("Loading packages (if any)...");
                const importRegex = /^(?:import|from)\s+([a-zA-Z0-9_.]+)/gm;
                let match;
                const packages = new Set();
                while ((match = importRegex.exec(python)) !== null) { packages.add(match[1].split('.')[0]); }
                 if (packages.size > 0) {
                    const nonStdLibPackages = [...packages].filter(p => !['sys', 'os', 'io', 'math', 'random', 'json', 'datetime', 'collections', 're'].includes(p));
                     if (nonStdLibPackages.length > 0) {
                         sendStatus(`Attempting to load packages: ${nonStdLibPackages.join(', ')}`);
                         await self.pyodide.loadPackage(nonStdLibPackages);
                     }
                 }

                sendStatus("Setting up filesystem...");
                self.pyodide.FS.mkdirTree(dataDir); 

                if (files && files.length > 0) {
                    sendStatus(`Loading ${files.length} file(s) into filesystem...`);
                    for (const file of files) {
                         try {
                            self.pyodide.FS.writeFile(`${dataDir}/${file.name}`, new Uint8Array(file.data));
                         } catch (fsError) { sendStatus(`FS Error writing ${file.name}: ${fsError.message}`); console.error(fsError); }
                    }
                }

                sendStatus("Preparing execution environment...");
                self.pyodide.runPython(`
                    import sys, os, io
                    data_dir = '/home/pyodide/data'
                    if os.path.exists(data_dir): os.chdir(data_dir)
                    _stdout_capture = io.StringIO()
                    _stderr_capture = io.StringIO()
                    sys.stdout = _stdout_capture
                    sys.stderr = _stderr_capture
                `);

                sendStatus("Running Python code...");
                let result = null;
                try {
                    result = await self.pyodide.runPythonAsync(python);
                } finally {
                    try {
                        stdout = self.pyodide.runPython("_stdout_capture.getvalue()") || "";
                        stderr = self.pyodide.runPython("_stderr_capture.getvalue()") || "";
                        self.pyodide.runPython("sys.stdout = sys.__stdout__; sys.stderr = sys.__stderr__");
                    } catch (captureError) {
                         console.error("Error capturing/restoring stdio:", captureError);
                         stderr += "\n[Worker: Error capturing/restoring stdio]";
                    }
                }

                sendStatus("Collecting modified files...");
                const modifiedFiles = [];
                try {
                    if (self.pyodide.FS.analyzePath(dataDir).exists) {
                         const dataFiles = self.pyodide.FS.readdir(dataDir);
                         for (const fileName of dataFiles.filter(name => name !== '.' && name !== '..')) {
                             const path = `${dataDir}/${fileName}`;
                             try {
                                 if (self.pyodide.FS.isFile(self.pyodide.FS.stat(path).mode)) {
                                     modifiedFiles.push({ name: fileName, data: self.pyodide.FS.readFile(path, { encoding: 'binary' }) });
                                 }
                             } catch (fileError) { console.error(`Error reading file ${fileName}:`, fileError); }
                         }
                    }
                } catch (fsError) { console.error("Error reading filesystem:", fsError); stderr += `\n[Worker: Error reading filesystem: ${fsError.message}]`; }

                self.postMessage({ id, status: "complete", result: result?.toString(), stdout, stderr, modifiedFiles });
                
            } catch (error) {
                 console.error("Pyodide Worker error:", error);
                 try { // Try to get final stderr
                     if (!stderr && self.pyodide) stderr = self.pyodide.runPython("_stderr_capture.getvalue()") || "";
                     if (self.pyodide) self.pyodide.runPython("sys.stdout = sys.__stdout__; sys.stderr = sys.__stderr__"); // Restore stdio
                 } catch(e) { /* ignore */ }
                 self.postMessage({ id, status: "error", error: error.message || "Unknown error", stderr });
            }
        };
    </script>
    
    <script id="r-webworker" type="text/web-worker">
        // webworker-webr.js
        // Runs as a module worker (type: 'module')
        
        // Import WebR class using ES Module syntax
        // The URL points to the module file (.mjs)
        import { WebR } from 'https://webr.r-wasm.org/latest/webr.mjs';

        let webR; // Holds the WebR instance
        let webRReadyPromise; // Promise that resolves when WebR is initialized

        // Async function to initialize WebR
        async function initializeWebR() {
            if (!webR) { 
                 self.postMessage({ status: 'init', message: 'Loading WebR runtime (module)...' });
                 try {
                    webR = new WebR(); // Instantiate the imported class
                    // self.webR = webR; // Optional: Assign to worker global scope if needed by other functions directly
                    await webR.init();
                    self.postMessage({ status: 'init', message: 'WebR runtime loaded (module).' });
                 } catch (error) {
                      console.error("WebR Initialization failed:", error);
                      self.postMessage({ status: 'error', error: `WebR Initialization failed: ${error.message}` });
                      throw error; // Re-throw to reject the promise
                 }
            }
            return webR;
        }

        // Start initializing WebR as soon as the worker script loads
        webRReadyPromise = initializeWebR();

        // Handler for messages from the main thread
        self.onmessage = async function(event) {
            const { id, rCode, files } = event.data;
            
            let currentWebR; // Use a local variable for the instance in this message scope
            try {
                 // Wait for the initialization promise to resolve
                 currentWebR = await webRReadyPromise; 
            } catch (error) {
                 // If initialization failed, post error and exit
                 self.postMessage({ id, status: "error", error: `WebR initialization previously failed: ${error.message}` });
                 return;
            }

            function sendStatus(status) { self.postMessage({ id, status }); }

            let stdout = "";
            let stderr = "";
            const dataDir = '/home/webR/data'; // Define dataDir

            try {
                sendStatus("Setting up filesystem...");
                await currentWebR.evalRVoid(`dir.create("${dataDir}", recursive = TRUE, showWarnings = FALSE)`);

                if (files && files.length > 0) {
                    sendStatus(`Loading ${files.length} file(s) into filesystem...`);
                    for (const file of files) {
                         try {
                            await currentWebR.FS.writeFile(`${dataDir}/${file.name}`, new Uint8Array(file.data));
                         } catch (fsError) { sendStatus(`FS Error writing ${file.name}: ${fsError.message}`); console.error(fsError); }
                    }
                }

                sendStatus("Preparing execution environment...");
                // Use R's sink() for output capture. Ensure directory exists.
                await currentWebR.evalRVoid(`
                    if (dir.exists("${dataDir}")) {
                        setwd("${dataDir}") 
                        
                        # Close any potentially orphaned sinks first
                        if(sink.number(type="output") > 0) sink(type = "output")
                        if(sink.number(type="message") > 0) sink(type = "message")
                        
                        output_con <- file("stdout.log", open = "wt")
                        error_con <- file("stderr.log", open = "wt")
                        sink(output_con, type = "output")
                        sink(error_con, type = "message") # Captures messages/warnings/errors
                    } else {
                        print("Error: Data directory not found for sink setup.")
                    }
                `);

                sendStatus("Running R code...");
                let result = null;
                try {
                    result = await currentWebR.evalR(rCode);
                } finally {
                    // Always close sinks and read captured output
                    try {
                        await currentWebR.evalRVoid(`
                            # Close the sinks if they were opened
                            if(exists("output_con")) {
                                sink(type = "output") 
                                sink(type = "message")
                                close(output_con)
                                close(error_con)
                            }
                        `);
                    
                        // Read captured output files if they exist
                         try {
                            stdout = await currentWebR.FS.readFile(`${dataDir}/stdout.log`, { encoding: 'utf8' }) || "";
                            await currentWebR.FS.unlink(`${dataDir}/stdout.log`); 
                         } catch (e) { /* File might not exist */ }
                         try {
                            stderr = await currentWebR.FS.readFile(`${dataDir}/stderr.log`, { encoding: 'utf8' }) || "";
                            await currentWebR.FS.unlink(`${dataDir}/stderr.log`); 
                         } catch (e) { /* File might not exist */ }
                    } catch (captureError) {
                         console.error("Error capturing/restoring R output:", captureError);
                         stderr += "\n[Worker: Error capturing/restoring R output]";
                    }
                }

                // ***** IMPORTANT: Resolve the main R script result FIRST *****
                let resolvedResultValue;
                try {
                    // If result holds the RObject:
                    console.log('[LOG] Resolving main R script execution result.');
                    
                    // Now convert the RObject result to a string safely
                    // Check if it's null/undefined before calling toString
                    resolvedResultValue = result ? await result.toString() : null;
                    
                    // Don't forget memory management for the result if not using shelters
                    // await currentWebR.destroy(result); // Add this if using evalR and not using shelters
                } catch (rExecutionError) {
                    console.error("Error processing R script result:", rExecutionError);
                    // Post error if processing the R result fails
                    self.postMessage({ id, status: "error", error: `Error processing R script result: ${rExecutionError.message}`, stderr });
                    return; // Stop further processing
                }

                // --- Now proceed with file collection ---
                sendStatus("Collecting modified files...");
                console.log('[LOG] Starting file collection process...'); // Added Log
                const modifiedFiles = []; // Initialize as empty array
                try {
                    console.log(`[LOG] Attempting to list files in dataDir: ${dataDir}`); // Added Log
                    // Use R's list.files() to get directory contents
                    const listFilesCmd = `list.files(path='${dataDir}', recursive=FALSE)`;
                    const dataFilesShelter = await currentWebR.evalR(listFilesCmd);
                    console.log('[LOG] list.files() RObject received:', dataFilesShelter); // Added Log
                    const dataFiles = await dataFilesShelter.toArray();
                    console.log(`[LOG] Files listed in ${dataDir}:`, dataFiles); // Added Log

                    // If list.files() succeeds, proceed to check and read files.
                    console.log('[LOG] Starting loop through listed files...'); // Added Log
                    for (const fileName of dataFiles.filter(name => name !== '.' && name !== '..')) {
                        const path = `${dataDir}/${fileName}`;
                        console.log(`[LOG] Processing file: ${fileName} at path: ${path}`); // Added Log
                        try {
                            console.log(`[LOG] Checking if ${path} is a directory...`); // Added Log
                            const isDirectory = await currentWebR.evalRBoolean(`dir.exists('${path}')`);
                            console.log(`[LOG] Is ${path} a directory? ${isDirectory}`); // Added Log

                            if (!isDirectory) {
                                console.log(`[LOG] ${path} is NOT a directory. Attempting to read file...`); // Added Log
                                // IMPORTANT: Await readFile here to resolve the Promise before pushing.
                                const fileData = await currentWebR.FS.readFile(path, { encoding: 'binary' });
                                console.log(`[LOG] Successfully read file ${fileName}. Type of fileData: ${typeof fileData}, Is ArrayBuffer/View: ${ArrayBuffer.isView(fileData) || fileData instanceof ArrayBuffer}`); // Added Log
                                // Check if fileData is still somehow a Promise (it shouldn't be after await)
                                if (fileData instanceof Promise) {
                                    console.error(`CRITICAL: fileData for ${fileName} IS STILL A PROMISE AFTER AWAIT!`);
                                }
                                modifiedFiles.push({ name: fileName, data: fileData });
                                console.log(`[LOG] Pushed { name: ${fileName}, data: [${typeof fileData}] } to modifiedFiles. Current array:`, modifiedFiles); // Added Log
                            } else {
                                console.log(`[LOG] Skipping directory: ${fileName}`); // Added Log
                            }
                        } catch (fileError) {
                            console.warn(`Error during check/read for entry ${fileName}:`, fileError); // Added Log
                            stderr += `\n[Worker: Error processing entry ${fileName}: ${fileError.message}]`;
                        }
                        console.log(`[LOG] Finished processing entry: ${fileName}`); // Added Log
                    }
                    console.log('[LOG] Finished loop through listed files.'); // Added Log
                } catch (fsError) {
                    console.error("Error during list.files() or loop setup:", fsError); // Added Log
                    // Handle errors during list.files() or subsequent processing
                    if (fsError.message.includes('cannot open')) {
                        // Directory likely doesn't exist or isn't accessible - often not a critical error here
                        console.log(`[LOG] Data directory ${dataDir} not found or empty (handled error).`); // Added Log
                    } else {
                        // Log other filesystem errors
                        console.error("Error listing or reading R filesystem:", fsError);
                        stderr += `\n[Worker: Error listing/reading R filesystem: ${fsError.message}]`;
                    }
                }

                // --- Prepare and send the final message ---
                // Use the resolved value here
                const resultString = resolvedResultValue ? resolvedResultValue.toString() : ""; // Ensure it's a string

                // Convert stdout/stderr Uint8Arrays to strings if needed
                let stdoutString = stdout;
                let stderrString = stderr;
                if (stdout instanceof Uint8Array) {
                    const decoder = new TextDecoder();
                    stdoutString = decoder.decode(stdout);
                }
                if (stderr instanceof Uint8Array) {
                    const decoder = new TextDecoder();
                    stderrString = decoder.decode(stderr);
                }

                console.log('[LOG] Preparing final message with resolved result and decoded streams.');
                // Send the STRING versions of stdout/stderr
                self.postMessage({
                    id,
                    status: "complete",
                    result: resultString,
                    stdout: stdoutString, // Send string
                    stderr: stderrString, // Send string
                    modifiedFiles
                });
                console.log('[LOG] postMessage call completed.');

            } catch (error) {
                 // Outer error (e.g., webR initialization, unexpected issues)
                 console.error("WebR Worker error:", error);
                 // Decode stderr here too for the error message if it's a Uint8Array
                 let errorStderrString = "";
                 try {
                     const decoder = new TextDecoder();
                     if (!stderr) { // Check if stderr was captured before the error
                        const stderrLogContent = await currentWebR.FS.readFile(`${dataDir}/stderr.log`, { encoding: 'utf8' });
                        errorStderrString = typeof stderrLogContent === 'string' ? stderrLogContent : decoder.decode(stderrLogContent || new Uint8Array());
                     } else {
                        errorStderrString = stderr instanceof Uint8Array ? decoder.decode(stderr) : stderr;
                     }
                     // Attempt to unlink log file only if it was potentially read
                     if (!stderr) await currentWebR.FS.unlink(`${dataDir}/stderr.log`); // [1]
                 } catch (e) {
                     console.warn("Could not retrieve or clean up stderr.log in error handler:", e);
                     if (typeof errorStderrString !== 'string') errorStderrString = "";
                 }
                 try { await currentWebR.evalRVoid(`if(sink.number()>0) sink()`); } catch(e) { /* ignore */ } // [2]

                 self.postMessage({ id, status: "error", error: error.message || "Unknown error", stderr: errorStderrString }); // Send string
            }
        };
    </script>

    <script>
        // --- Global State ---
        const allFiles = [];
        let selectedFile = null;
        const includedForRun = [];
        
        // Persistent workers & message handling
        let pyodideWorker = null;
        let webRWorker = null;
        const workerPromises = {}; // Store { id: { resolve, reject, workerType } }
        let messageIdCounter = 1;

        // --- DOM Elements ---
        const filesDropZone = document.getElementById('filesDropZone');
        const filesList = document.getElementById('filesList');
        const previewPanel = document.getElementById('previewPanel');
        const terminalContent = document.getElementById('terminalContent');
        const clearTerminalBtn = document.getElementById('clearTerminal');

        // --- Worker Initialization & Management ---
        
        function getPyodideWorker() {
            if (!pyodideWorker) {
                log("Initializing Python (Pyodide) worker...");
                try {
                    const workerScript = document.getElementById('pyodide-webworker').textContent;
                    const blob = new Blob([workerScript], { type: 'application/javascript' });
                    const workerUrl = URL.createObjectURL(blob);
                    // Pyodide uses a classic worker
                    pyodideWorker = new Worker(workerUrl); 
                    
                    pyodideWorker.onmessage = handleWorkerMessage;
                    pyodideWorker.onerror = (event) => handleWorkerError(event, 'python');
                    URL.revokeObjectURL(workerUrl); // Clean up blob URL after worker creation
                } catch (error) {
                     log(`Failed to create Pyodide worker: ${error.message}`, 'error');
                     console.error("Pyodide Worker Creation Error:", error);
                     pyodideWorker = null; // Ensure it's null if creation failed
                }
            }
            return pyodideWorker;
        }

        function getWebRWorker() {
            if (!webRWorker) {
                log("Initializing R (WebR) worker (as module)...");
                 try {
                    const workerScript = document.getElementById('r-webworker').textContent;
                    const blob = new Blob([workerScript], { type: 'application/javascript' });
                    const workerUrl = URL.createObjectURL(blob);
                    
                    // *** Create as a MODULE worker ***
                    webRWorker = new Worker(workerUrl, { type: 'module' }); 

                    webRWorker.onmessage = handleWorkerMessage;
                    webRWorker.onerror = (event) => handleWorkerError(event, 'r');
                    URL.revokeObjectURL(workerUrl); // Clean up blob URL
                 } catch (error) {
                     log(`Failed to create WebR worker: ${error.message}`, 'error');
                     console.error("WebR Worker Creation Error:", error);
                     webRWorker = null;
                 }
            }
            return webRWorker;
        }
        
        function handleWorkerError(event, workerType) {
             log(`${workerType.toUpperCase()} Worker Error: ${event.message}`, 'error');
             console.error(`${workerType.toUpperCase()} Worker Error Event:`, event);
             // Reject all pending promises for this worker type
             Object.keys(workerPromises).forEach(id => {
                 if (workerPromises[id]?.workerType === workerType) {
                     workerPromises[id].reject(new Error(`${workerType.toUpperCase()} Worker Error: ${event.message || 'Unknown error'}`));
                     delete workerPromises[id];
                 }
             });
             // Nullify the worker instance so it can be recreated if needed
             if (workerType === 'python') pyodideWorker = null;
             if (workerType === 'r') webRWorker = null;
        }

        // --- Message Handling ---

        function handleWorkerMessage(event) {
            const data = event.data;
            const id = data.id;

            if (data.status === 'init') {
                 log(`Worker: ${data.message}`);
                 return;
            }
            
            const promiseInfo = id ? workerPromises[id] : null;
            
            if (promiseInfo) {
                const { resolve, reject, workerType } = promiseInfo;
                
                if (data.status === "complete") {
                    log(`Execution complete (ID: ${id}, Type: ${workerType})`, 'success');
                    if (data.stdout) log(`Stdout:\n${data.stdout}`);
                    if (data.stderr) log(`Stderr:\n${data.stderr}`, data.stderr.trim() ? 'warning' : 'info');
                    if (data.result != null) log(`Result: ${data.result}`); // Check for null/undefined explicitly
                    resolve(data);
                    delete workerPromises[id]; // Clean up handled promise
                } else if (data.status === "error") {
                    log(`Execution Error (ID: ${id}, Type: ${workerType}): ${data.error}`, 'error');
                    if (data.stderr) log(`Stderr:\n${data.stderr}`, 'error');
                    reject(new Error(data.error || "Unknown worker error")); 
                    delete workerPromises[id];
                } else {
                    // General status update
                    log(`Worker Status (ID: ${id}, Type: ${workerType}): ${data.status}`);
                }
            } else if (data.status === "error" && !id) {
                // Handle initialization errors without a specific message ID
                log(`Worker Initialization Error: ${data.error}`, 'error');
            } else {
                 console.warn("Received worker message with unknown or missing ID:", data);
            }
        }

        function generateId() {
            return messageIdCounter++;
        }

        async function postTaskToWorker(worker, taskData, workerType) {
             if (!worker) {
                 log(`Cannot post task: ${workerType} worker is not available.`, 'error');
                 return Promise.reject(new Error(`${workerType} worker not available.`));
             }
            const id = generateId();
            taskData.id = id;
            
            return new Promise((resolve, reject) => {
                workerPromises[id] = { resolve, reject, workerType };
                 try {
                    worker.postMessage(taskData);
                 } catch (postError) {
                     log(`Error posting message to ${workerType} worker: ${postError.message}`, 'error');
                     console.error("Post Message Error:", postError);
                     reject(postError);
                     delete workerPromises[id];
                 }
            });
        }
        
        // --- Logging ---
        function log(message, type = 'info') {
            // Check if terminal content area exists
            if (!terminalContent) {
                console.warn("Terminal content area not found. Logging to console instead:", message);
                return;
            }
            
            const timestamp = new Date().toLocaleTimeString();
            const logElement = document.createElement('div');
            // Basic sanitation to prevent HTML injection
            const safeMessage = message.toString().replace(/</g, "&lt;").replace(/>/g, "&gt;");
            logElement.innerHTML = `[${timestamp}] ${safeMessage}`; 
            
            // Apply class based on type
            logElement.classList.add('log-entry', type); // Add type as a class

            terminalContent.appendChild(logElement);
            // Scroll to bottom
            terminalContent.scrollTop = terminalContent.scrollHeight;
        }

        clearTerminalBtn?.addEventListener('click', () => { // Add null check
            if (terminalContent) terminalContent.innerHTML = '';
            log('Terminal cleared');
        });

        // --- Core Execution Logic ---

        async function runPythonScript(scriptContent, additionalFiles = []) {
            const worker = getPyodideWorker(); // Get (and potentially initialize) worker
            if (!worker) return Promise.reject("Pyodide worker failed to initialize.");
            
            log(`Sending Python task to worker...`);
            const fileData = await Promise.all(additionalFiles.map(async (file) => ({
                name: file.name, data: await file.arrayBuffer()
            })));
            return postTaskToWorker(worker, { python: scriptContent, files: fileData }, 'python');
        }

        async function runRScript(scriptContent, additionalFiles = []) {
            const worker = getWebRWorker(); // Get (and potentially initialize) worker
            if (!worker) return Promise.reject("WebR worker failed to initialize.");

            log(`Sending R task to worker...`, 'r'); 
            const fileData = await Promise.all(additionalFiles.map(async (file) => ({
                name: file.name, data: await file.arrayBuffer()
            })));
            return postTaskToWorker(worker, { rCode: scriptContent, files: fileData }, 'r');
        }

        // --- File Handling & UI ---

        function handleFileSelect(files) {
            let filesAdded = false;
            Array.from(files).forEach(file => {
                if (!allFiles.some(f => f.name === file.name)) {
                    const fileObj = file;
                    const nameLower = file.name.toLowerCase();
                    fileObj.isPython = nameLower.endsWith('.py');
                    fileObj.isR = nameLower.endsWith('.r'); 
                    fileObj.isData = !fileObj.isPython && !fileObj.isR; // Simple data file flag
                    
                    allFiles.push(fileObj);
                    log(`Added file: ${file.name} ${fileObj.isPython ? '(Python)' : ''}${fileObj.isR ? '(R)' : ''}${fileObj.isData ? '(Data)' : ''}`);
                    filesAdded = true;
                } else {
                    log(`File ${file.name} already exists, skipping.`, 'warning');
                }
            });
            if (filesAdded) updateFileList();
        }
        
        function getFileIcon(file) {
            if (file.isPython) return '<span class="file-icon python">üêç</span>';
            if (file.isR) return '<span class="file-icon r">üá∑</span>'; 
            // Basic data icons (can be expanded)
            const ext = file.name.split('.').pop().toLowerCase();
            if (['csv', 'tsv', 'txt'].includes(ext)) return '<span class="file-icon data">üìÑ</span>'; 
            if (['parquet', 'json', 'xml', 'yaml', 'yml'].includes(ext)) return '<span class="file-icon data">üì¶</span>'; 
            if (['png', 'jpg', 'jpeg', 'gif', 'svg', 'webp'].includes(ext)) return '<span class="file-icon data">üñºÔ∏è</span>'; 
            return '<span class="file-icon">‚ùì</span>'; // Default
        }

        function updateFileList() {
            const instructionsElement = document.getElementById('filesInstructions');
            if (instructionsElement) instructionsElement.style.display = allFiles.length > 0 ? 'none' : 'flex';
            
            if (!filesList) return; // Guard if element doesn't exist
            filesList.innerHTML = ''; // Clear previous list
            
            if (allFiles.length > 0) {
                // Action buttons
                const actionButtonsHTML = `
                    <div class="action-buttons">
                        <button id="runSelectedFiles" class="btn btn-run" disabled>Run</button>
                        <button id="includeInRunFiles" class="btn btn-include" disabled>Include in Run</button>
                        <button id="downloadSelectedFiles" class="btn btn-download" disabled>Download</button>
                        <button id="removeSelectedFiles" class="btn btn-remove" disabled>Delete</button>
                    </div>`;
                filesList.insertAdjacentHTML('beforeend', actionButtonsHTML);

                // Table
                const tableHTML = `
                    <table class="file-table">
                        <thead>
                            <tr>
                                <th><input type="checkbox" id="selectAllFiles"></th>
                                <th class="sortable sort-active sort-asc" data-sort="name">Name</th>
                                <th class="sortable" data-sort="size">Size</th>
                                <th class="sortable" data-sort="date">Last Modified</th>
                            </tr>
                        </thead>
                        <tbody></tbody>
                    </table>`;
                filesList.insertAdjacentHTML('beforeend', tableHTML);
                const tbody = filesList.querySelector('tbody');
                
                allFiles.forEach(file => {
                    const tr = document.createElement('tr');
                    tr.className = `file-row ${file.isR ? 'is-r' : ''}`; 
                    const date = new Date(file.lastModified);
                    const dateString = date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }); // Shorter time
                    const sizeString = file.size < 1024 ? `${file.size} B` :
                                     file.size < 1024 * 1024 ? `${(file.size / 1024).toFixed(1)} KB` :
                                     `${(file.size / (1024 * 1024)).toFixed(1)} MB`;
                    
                    let nameCellHTML = `${getFileIcon(file)}${file.name}`;
                    if (includedForRun.some(f => f.name === file.name)) {
                         nameCellHTML += ' <span class="included-badge">included</span>';
                    }

                    tr.innerHTML = `
                        <td><input type="checkbox" class="file-checkbox" data-filename="${file.name}"></td>
                        <td data-value="${file.name.toLowerCase()}">${nameCellHTML}</td>
                        <td data-value="${file.size}">${sizeString}</td>
                        <td data-value="${file.lastModified}">${dateString}</td>
                    `;
                    tr.dataset.name = file.name.toLowerCase();
                    tr.dataset.size = String(file.size);
                    tr.dataset.date = String(file.lastModified);
                    
                    tr.addEventListener('click', (e) => {
                        if (e.target.type !== 'checkbox' && !e.target.closest('button')) { // Avoid clicks on checkbox/buttons
                            selectFile(file);
                        }
                    });
                    tbody?.appendChild(tr); // Add null check for tbody
                });

                // --- Add Event Listeners (using event delegation where possible) ---
                filesList.addEventListener('change', (e) => {
                    if (e.target.matches('#selectAllFiles')) {
                         filesList.querySelectorAll('.file-checkbox').forEach(cb => cb.checked = e.target.checked);
                         updateActionButtonsState();
                    } else if (e.target.matches('.file-checkbox')) {
                         updateActionButtonsState();
                    }
                });

                filesList.addEventListener('click', (e) => {
                    if (e.target.matches('#runSelectedFiles')) runSelected();
                    else if (e.target.matches('#includeInRunFiles')) includeSelected();
                    else if (e.target.matches('#downloadSelectedFiles')) downloadSelected();
                    else if (e.target.matches('#removeSelectedFiles')) removeSelected();
                    else if (e.target.matches('.sortable')) handleSort(e.target);
                });
                
            } else {
                 if(selectedFile) clearPreview();
            }
             updateActionButtonsState(); // Update button states initially
        }
        
        function handleSort(header) {
            const tbody = filesList?.querySelector('tbody');
            if (!tbody || !header) return;

             const sortBy = header.dataset.sort;
             const currentIsAsc = header.classList.contains('sort-asc');
             const isAsc = !currentIsAsc; 

             // Reset others
             filesList.querySelectorAll('.sortable').forEach(h => h.classList.remove('sort-active', 'sort-asc', 'sort-desc'));
             // Set this header
             header.classList.add('sort-active', isAsc ? 'sort-asc' : 'sort-desc');

             const rows = Array.from(tbody.querySelectorAll('tr'));
             rows.sort((a, b) => {
                 let aValue = a.dataset[sortBy];
                 let bValue = b.dataset[sortBy];
                 if (sortBy === 'size' || sortBy === 'date') { aValue = Number(aValue); bValue = Number(bValue); }
                 if (aValue < bValue) return isAsc ? -1 : 1;
                 if (aValue > bValue) return isAsc ? 1 : -1;
                 return 0;
             });
             rows.forEach(row => tbody.appendChild(row)); // Re-append sorted
        }

        function getSelectedFiles() {
            const selectedFilenames = Array.from(filesList?.querySelectorAll('.file-checkbox:checked') || [])
                                         .map(cb => cb.dataset.filename);
            return allFiles.filter(f => selectedFilenames.includes(f.name));
        }

        function updateActionButtonsState() {
            const runButton = document.getElementById('runSelectedFiles');
            const includeButton = document.getElementById('includeInRunFiles');
            const downloadButton = document.getElementById('downloadSelectedFiles');
            const removeButton = document.getElementById('removeSelectedFiles');
            
            if (!runButton) return; // Buttons don't exist if no files

            const selected = getSelectedFiles();
            const hasSelection = selected.length > 0;
            
            includeButton.disabled = !hasSelection;
            downloadButton.disabled = !hasSelection;
            removeButton.disabled = !hasSelection;

            const selectedScripts = selected.filter(f => f.isPython || f.isR);
            const hasPython = selectedScripts.some(f => f.isPython);
            const hasR = selectedScripts.some(f => f.isR);
            const canRun = selectedScripts.length > 0 && !(hasPython && hasR); 

            runButton.disabled = !canRun;
            runButton.classList.remove('run-r'); 
            if (canRun) {
                runButton.textContent = hasPython ? 'Run Python' : 'Run R';
                 if (hasR) runButton.classList.add('run-r'); 
            } else {
                 runButton.textContent = 'Run'; 
            }
        }

        async function runSelected() {
             const selectedScripts = getSelectedFiles().filter(f => f.isPython || f.isR);
             if (selectedScripts.length === 0) return;

             const isPythonRun = selectedScripts[0].isPython;
             const runner = isPythonRun ? executePythonFile : executeRFile;
             const type = isPythonRun ? 'Python' : 'R';

             log(`Executing ${selectedScripts.length} ${type} script(s)...`);
             // Run sequentially for clearer logs, could be parallelized with Promise.all
             for (const file of selectedScripts) {
                 await runner(file).catch(err => log(`Execution failed for ${file.name}: ${err.message}`, 'error')); 
             }
             log(`${type} execution task(s) finished.`);
        }

        function includeSelected() {
             const selected = getSelectedFiles();
             let includedNew = false;
             selected.forEach(file => {
                 if (!includedForRun.some(f => f.name === file.name)) {
                     includedForRun.push(file);
                     log(`Included file for subsequent runs: ${file.name}`, 'success');
                     includedNew = true;
                 } else {
                      log(`File ${file.name} was already included.`, 'info');
                 }
             });
             if (includedNew) {
                  // Clear selections and update UI
                  filesList?.querySelectorAll('.file-checkbox:checked').forEach(cb => cb.checked = false);
                  const selectAll = document.getElementById('selectAllFiles');
                  if (selectAll) selectAll.checked = false;
                  updateFileList(); // Re-render to show badges & update buttons
             }
        }
        
        function downloadSelected() {
             const selected = getSelectedFiles();
             if (selected.length === 0) return;

             const downloadFile = (blob, filename) => {
                 const url = URL.createObjectURL(blob);
                 const a = document.createElement('a');
                 a.href = url; a.download = filename; a.click(); 
                 setTimeout(() => URL.revokeObjectURL(url), 100); // Delay revoke slightly
                 log(`Downloaded: ${filename}`, 'success');
             };

             if (selected.length === 1) {
                 downloadFile(selected[0], selected[0].name);
             } else {
                 log('Loading JSZip to archive multiple files...');
                 const script = document.createElement('script');
                 script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
                 script.onload = async () => {
                     try {
                         const zip = new JSZip();
                         selected.forEach(file => zip.file(file.name, file));
                         const content = await zip.generateAsync({ type: 'blob' });
                         downloadFile(content, 'files.zip');
                     } catch (error) { log(`Error creating zip file: ${error.message}`, 'error'); }
                 };
                 script.onerror = () => log('Failed to load JSZip library.', 'error');
                 document.head.appendChild(script);
                 script.remove(); // Clean up script tag after loading
             }
        }

        function removeSelected() {
             const selectedNames = getSelectedFiles().map(f => f.name);
             if (selectedNames.length === 0) return;

             let fileRemoved = false;
             for (let i = allFiles.length - 1; i >= 0; i--) {
                 if (selectedNames.includes(allFiles[i].name)) {
                     log(`Deleted file: ${allFiles[i].name}`, 'warning');
                     allFiles.splice(i, 1);
                     fileRemoved = true;
                 }
             }
             // Remove from included list too
             for (let i = includedForRun.length - 1; i >= 0; i--) {
                 if (selectedNames.includes(includedForRun[i].name)) {
                     includedForRun.splice(i, 1);
                 }
             }

             if (fileRemoved) {
                 if (selectedFile && selectedNames.includes(selectedFile.file.name)) clearPreview();
                 updateFileList(); 
             }
        }
        
         function handleModifiedFiles(modifiedFiles) {
            // (Code from previous version - unchanged)
             if (!modifiedFiles || modifiedFiles.length === 0) return;
            log(`Processing ${modifiedFiles.length} modified/new files from execution...`, 'info');

            let fileListChanged = false;
            modifiedFiles.forEach(modFile => {
                 const blob = new Blob([modFile.data], { type: modFile.type || 'application/octet-stream' }); 
                 const file = new File([blob], modFile.name, { lastModified: Date.now() });
                 const nameLower = file.name.toLowerCase();
                 file.isPython = nameLower.endsWith('.py');
                 file.isR = nameLower.endsWith('.r');
                 file.isData = !file.isPython && !file.isR;

                 const existingIndex = allFiles.findIndex(f => f.name === file.name);
                 if (existingIndex !== -1) {
                     allFiles[existingIndex] = file; 
                     log(`Updated file: ${file.name}`, 'success');
                 } else {
                     allFiles.push(file); 
                     log(`Added new file: ${file.name}`, 'success');
                 }
                 fileListChanged = true;
            });

            if (fileListChanged) {
                 updateFileList(); 
                 if (selectedFile && modifiedFiles.some(mf => mf.name === selectedFile.file.name)) {
                     const updatedFile = allFiles.find(f => f.name === selectedFile.file.name);
                     if (updatedFile) {
                         selectFile(updatedFile); // Re-select to refresh preview
                         log(`Refreshed preview for updated file: ${updatedFile.name}`);
                     }
                 }
            }
         }

        // Execute Python File (main logic)
        async function executePythonFile(file) {
            log(`Executing Python file: ${file.name}...`);
            const content = await file.text();
            const dataFiles = [...includedForRun]; 
            getSelectedFiles().forEach(selected => { // Add selected data files if not already included
                if (selected.isData && !dataFiles.some(df => df.name === selected.name)) {
                    dataFiles.push(selected);
                }
            });
            if (dataFiles.length > 0) log(`Including ${dataFiles.length} data file(s) for Python run.`);
            
            try {
                const result = await runPythonScript(content, dataFiles);
                if (result.modifiedFiles?.length > 0) handleModifiedFiles(result.modifiedFiles);
            } catch (error) {
                log(`Failed Python execution for ${file.name}: ${error.message || error}`, 'error');
            }
        }

        // Execute R File (main logic)
        async function executeRFile(file) {
            log(`Executing R file: ${file.name}...`, 'r');
            const content = await file.text();
            const dataFiles = [...includedForRun]; 
            getSelectedFiles().forEach(selected => { // Add selected data files
                if (selected.isData && !dataFiles.some(df => df.name === selected.name)) {
                    dataFiles.push(selected);
                }
            });
            if (dataFiles.length > 0) log(`Including ${dataFiles.length} data file(s) for R run.`, 'r');

            try {
                const result = await runRScript(content, dataFiles);
                if (result.modifiedFiles?.length > 0) handleModifiedFiles(result.modifiedFiles);
            } catch (error) {
                log(`Failed R execution for ${file.name}: ${error.message || error}`, 'error');
            }
        }
        
        // --- File Preview ---
        function selectFile(file) {
            selectedFile = { file }; 
            // Highlight row
            document.querySelectorAll('.file-row').forEach(row => {
                 const nameCell = row.querySelector('td:nth-child(2)');
                 row.classList.toggle('active', nameCell && nameCell.textContent.includes(file.name));
            });
            previewFile(file); // Trigger preview
        }
        
        function clearPreview() {
             if (previewPanel) previewPanel.innerHTML = '<div class="empty-state">Select a File to Preview</div>';
             selectedFile = null;
        }

        async function previewParquetFile(file) {
            // (Code from previous version - unchanged)
            log(`Loading parquet preview for ${file.name}...`);
            if (!previewPanel) return;
            previewPanel.innerHTML = `<div>Loading parquet file: ${file.name}...</div>`; 
            
            try {
                 const { parquetReadObjects, parquetMetadataAsync, parquetSchema } = 
                    await import('https://cdn.jsdelivr.net/npm/hyparquet/src/hyparquet.min.js');

                 const buffer = await file.arrayBuffer();
                 const metadata = await parquetMetadataAsync(buffer);
                 const schema = parquetSchema(metadata);
                 const numRows = Number(metadata.num_rows);
                 const columnNames = schema.children.map(c => c.element.name);
                 const previewRowCount = Math.min(100, numRows);
                 const data = await parquetReadObjects({ file: buffer, columns: columnNames, rowStart: 0, rowEnd: previewRowCount });

                 let tableHTML = `<div style="overflow: auto; max-height: 400px;"><table class="parquet-table"><thead><tr>${columnNames.map(col => `<th>${col}</th>`).join('')}</tr></thead><tbody>`;
                 data.forEach(row => { tableHTML += `<tr>${columnNames.map(col => `<td>${row[col] ?? 'null'}</td>`).join('')}</tr>`; });
                 tableHTML += `</tbody></table></div>`;

                 const schemaInfo = columnNames.map(name => { const child = schema.children.find(c => c.element.name === name); return `${name}: ${child?.element?.type ?? 'unknown'}`; }).join('<br>');
                 let infoHTML = `<div style="margin-top: 15px; font-size: 0.9rem; color: #666;"><div><strong>Rows:</strong> ${numRows} | <strong>Columns:</strong> ${columnNames.length} | <strong>Preview:</strong> ${previewRowCount} rows</div><div style="margin-top: 10px;"><strong>Schema:</strong><pre style="font-size: 0.8rem;">${schemaInfo}</pre></div></div>`;
                 
                 previewPanel.innerHTML = tableHTML + infoHTML;
                 log(`Parquet preview loaded: ${file.name}`, 'success');

            } catch (error) {
                 previewPanel.innerHTML = `<div class="error">Error reading parquet file: ${error.message}</div>`;
                 log(`Error reading parquet file ${file.name}: ${error.message}`, 'error'); console.error(error);
            }
        }
        
        function previewHtmlFile(content) {
             // (Code from previous version - unchanged)
            if (!previewPanel) return;
             const iframeContainer = document.createElement('div');
             iframeContainer.style.cssText = 'width: 100%; height: 500px; border: 1px solid #ddd; border-radius: 4px; overflow: hidden;';
             const iframe = document.createElement('iframe');
             iframe.style.cssText = 'width: 100%; height: 100%; border: none;';
             iframe.sandbox = 'allow-scripts allow-same-origin'; 
             iframeContainer.appendChild(iframe);
             previewPanel.appendChild(iframeContainer);
             
             if ('srcdoc' in iframe) iframe.srcdoc = content;
             else { iframe.contentWindow.document.open(); iframe.contentWindow.document.write(content); iframe.contentWindow.document.close(); }
        }
        
        function previewFile(file) {
            // (Code largely from previous version - minor tweaks)
             if (!previewPanel) return;
            previewPanel.innerHTML = ''; // Clear

            const header = document.createElement('div');
            header.style.cssText = 'padding-bottom: 15px; border-bottom: 1px solid #eee; margin-bottom: 15px; display: flex; justify-content: space-between; align-items: center;';
            header.innerHTML = `<strong>${file.name}</strong> (${(file.size / 1024).toFixed(1)} KB)`;
            
            if (file.isPython || file.isR) {
                const runButton = document.createElement('button');
                runButton.textContent = `Run ${file.isPython ? 'Python' : 'R'} Script`;
                runButton.className = `run-button ${file.isR ? 'run-r' : ''}`; 
                runButton.addEventListener('click', (e) => { 
                    e.stopPropagation(); // Prevent row selection
                    if (file.isPython) executePythonFile(file); else if (file.isR) executeRFile(file); 
                });
                header.appendChild(runButton);
            }
            previewPanel.appendChild(header);

            const ext = file.name.split('.').pop().toLowerCase();
            const reader = new FileReader();

            reader.onload = (e) => {
                const content = e.target.result;
                 if (ext === 'html') previewHtmlFile(content);
                 else if (['py', 'r', 'txt', 'json', 'csv', 'log', 'md', 'yaml', 'yml', 'sql'].includes(ext) || file.type.startsWith('text/')) {
                     const codePreview = document.createElement('pre');
                     codePreview.className = 'code-preview';
                     codePreview.textContent = content; 
                     previewPanel.appendChild(codePreview);
                 } else {
                     previewPanel.innerHTML += `<div class="error">Cannot display binary file content.</div>`;
                 }
            };
            reader.onerror = () => {
                previewPanel.innerHTML += '<div class="error">Error reading file for preview.</div>';
                log(`Error reading file ${file.name} for preview`, 'error');
            };

            if (ext === 'parquet') previewParquetFile(file);
            else if (file.type.startsWith('image/')) {
                 const img = document.createElement('img');
                 img.src = URL.createObjectURL(file);
                 img.style.cssText = 'max-width: 100%; max-height: 400px; display: block; margin-top: 10px;';
                 img.onload = () => URL.revokeObjectURL(img.src); 
                 previewPanel.appendChild(img);
                 log(`Previewing image: ${file.name}`);
            } else if (file.size > 5 * 1024 * 1024) { // Limit text preview size
                 previewPanel.innerHTML += `<div class="warning">File is large (${(file.size / (1024*1024)).toFixed(1)} MB). Text preview skipped.</div>`;
                 log(`Skipping text preview for large file: ${file.name}`, 'warning');
            } else if (['py', 'r', 'txt', 'json', 'csv', 'log', 'md', 'yaml', 'yml', 'sql'].includes(ext) || file.type.startsWith('text/')) {
                 reader.readAsText(file);
            } else {
                 previewPanel.innerHTML += '<div>No preview available for this file type.</div>';
                 log(`No preview available for: ${file.name} (${file.type || ext})`);
            }
        }

        // --- Drag and Drop & Click to Upload Setup ---
        function setupDropZone(dropZone) {
            if (!dropZone) return;
            
            // Prevent default drag behaviors
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, (e) => { e.preventDefault(); e.stopPropagation(); }, false);
            });

            // Highlight on drag enter/over
            ['dragenter', 'dragover'].forEach(eventName => {
                dropZone.addEventListener(eventName, () => dropZone.classList.add('active'), false);
            });

            // Unhighlight on drag leave/drop
            ['dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, () => dropZone.classList.remove('active'), false);
            });
            
            // Handle dropped files
            dropZone.addEventListener('drop', (e) => {
                handleFileSelect(e.dataTransfer.files);
            }, false);

            // Handle click to upload
            dropZone.addEventListener('click', (e) => {
                 // Only trigger if clicking the instructions area or the zone itself, not the file list
                 if (e.target.closest('#filesInstructions') || e.target === dropZone) {
                     const fileInput = document.createElement('input');
                     fileInput.type = 'file';
                     fileInput.multiple = true;
                     fileInput.style.display = 'none'; // Hide the input
                     fileInput.onchange = (ev) => handleFileSelect(ev.target.files);
                     document.body.appendChild(fileInput); // Add to body to ensure it works on all browsers
                     fileInput.click();
                     document.body.removeChild(fileInput); // Clean up input element after loading
                 }
            });
        }

        // --- Initialization ---
        function init() {
            // Ensure DOM is ready (though script at end usually suffices)
             if (document.readyState === 'loading') {
                 document.addEventListener('DOMContentLoaded', runInit);
             } else {
                 runInit();
             }
        }
        
        function runInit() {
             setupDropZone(filesDropZone);
             log('App initialized. Ready for Python (.py) and R (.R) files.');
             // Optional: Pre-warm workers on load (can increase initial load time)
             // setTimeout(() => getPyodideWorker(), 100); 
             // setTimeout(() => getWebRWorker(), 200); 
        }

        // Start the app
        init();
    </script>
</body>
</html>