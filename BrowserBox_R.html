<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BrowserBox - Py & R Runner</title>
    <style>
        /* --- CSS (No changes from previous version) --- */
        :root {
            --primary-bg: #ffffff;
            --panel-bg: #f9f9f9;
            --border-color: #e0e0e0;
            --accent-color: #3498db; /* Blue for Python */
            --r-accent-color: #1e8449; /* Green for R */
            --text-color: #333333;
            --secondary-text: #666666;
            --terminal-bg: #2d3436;
            --terminal-text: #ecf0f1;
            --drop-zone-hover: rgba(52, 152, 219, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        }

        body {
            background-color: var(--primary-bg);
            color: var(--text-color);
            height: 100vh;
            padding: 20px;
        }

        .container {
            display: grid;
            grid-template-columns: 2fr 3fr;
            grid-template-rows: 2fr 1fr;
            grid-template-areas:
                "left right"
                "terminal terminal";
            gap: 16px;
            height: calc(100vh - 40px);
        }

        .drop-zone {
            background-color: var(--panel-bg);
            border: 2px dashed #777777;
            border-radius: 8px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            transition: all 0.3s ease;
            overflow: auto;
        }
        
        .drop-zone #filesInstructions {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            height: 100%;
            cursor: pointer; /* Make instructions area clickable */
        }

        .drop-zone:hover {
            background-color: var(--drop-zone-hover);
        }

        .drop-zone.active {
            border-color: var(--accent-color);
            background-color: var(--drop-zone-hover);
        }

        .drop-zone p {
            margin-bottom: 8px;
            font-weight: 500;
        }

        .sub-text {
            font-size: 0.8rem;
            color: var(--secondary-text);
        }

        .files-drop {
            grid-area: left;
        }

        .preview-panel {
            grid-area: right;
            background-color: var(--panel-bg);
            border-radius: 8px;
            padding: 20px;
            overflow: auto;
            display: flex;
            flex-direction: column;
            border: 2px solid #777777;
        }

        .preview-panel .empty-state {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100%;
            color: var(--secondary-text);
        }

        .terminal {
            grid-area: terminal;
            background-color: var(--terminal-bg);
            border-radius: 8px;
            color: var(--terminal-text);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .terminal-header {
            padding: 8px 16px;
            background-color: rgba(255, 255, 255, 0.05);
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .terminal-header button {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            color: var(--terminal-text);
            padding: 2px 8px;
            cursor: pointer;
            font-size: 0.8rem;
        }

        .terminal-header button:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .terminal-content {
            padding: 16px;
            overflow-y: auto;
            flex-grow: 1;
            font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.4;
            white-space: pre-wrap;
        }

        .file-list {
            list-style: none;
            width: 100%;
            margin-top: 10px;
        }

        .file-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
            font-size: 0.9rem;
        }

        .file-table th {
            text-align: left;
            padding: 6px 8px;
            border-bottom: 1px solid var(--border-color);
            font-weight: 500;
            color: var(--secondary-text);
        }
        
        .action-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .btn {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .btn-run {
            background-color: var(--accent-color); /* Default blue for Python */
            color: white;
        }
        
        .btn-run.run-r { /* Specific style for R */
            background-color: var(--r-accent-color);
        }
        
        .btn-run:hover:not(:disabled) {
            filter: brightness(90%); /* Generic hover effect */
        }
        
        .btn-remove {
            background-color: #e74c3c;
            color: white;
        }
        
        .btn-remove:hover:not(:disabled) {
            background-color: #c0392b;
        }
        
        .btn-download {
            background-color: #27ae60;
            color: white;
        }
        
        .btn-download:hover:not(:disabled) {
            background-color: #219651;
        }
        
        .btn-include {
            background-color: #8e44ad;
            color: white;
        }
        
        .btn-include:hover:not(:disabled) {
            background-color: #7d3c98;
        }
        
        .included-badge {
            display: inline-block;
            background-color: #8e44ad;
            color: white;
            font-size: 0.7rem;
            padding: 2px 6px;
            border-radius: 10px;
            margin-left: 6px;
            vertical-align: middle;
        }
        
        .sortable {
            cursor: pointer;
            position: relative;
            padding-right: 18px !important;
        }
        
        .sortable:after {
            content: "↑↓";
            font-size: 0.7em;
            position: absolute;
            right: 6px;
            opacity: 0.3;
        }
        
        .sortable.sort-active:after {
            opacity: 1;
        }
        
        .sortable.sort-asc:after {
            content: "↑";
        }
        
        .sortable.sort-desc:after {
            content: "↓";
        }

        .file-table td {
            padding: 8px;
            border-bottom: 1px solid var(--border-color);
        }

        .file-row {
            cursor: pointer;
        }

        .file-row:hover {
            background-color: rgba(0, 0, 0, 0.05);
        }

        .file-row.active {
            background-color: var(--accent-color);
            color: white;
        }
        .file-row.active.is-r { /* Style for active R row */
             background-color: var(--r-accent-color);
        }
        
        .file-row.active td {
            border-bottom-color: var(--accent-color);
        }
        .file-row.active.is-r td {
             border-bottom-color: var(--r-accent-color);
        }

        .file-icon {
            margin-right: 4px;
            font-size: 1.1rem;
            color: #555; /* Default icon color */
        }
        .file-icon.python { color: var(--accent-color); } /* Python icon color */
        .file-icon.r { color: var(--r-accent-color); }     /* R icon color */
        .file-icon.data { color: #f39c12; } /* Example data icon color */
        
        .file-checkbox {
            cursor: pointer;
            width: 16px;
            height: 16px;
        }

        .file-preview {
            width: 100%;
            height: 100%;
            overflow: auto;
            text-align: left;
        }

        .code-preview {
            padding: 16px;
            font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.4;
            background-color: #f5f5f5;
            border-radius: 4px;
            white-space: pre;
            overflow-x: auto;
        }

        .run-button {
            background-color: var(--accent-color); /* Default Blue */
            color: white;
            border: none;
            border-radius: 4px;
            padding: 6px 12px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background-color 0.2s;
        }
        
        .run-button.run-r { /* R run button color */
             background-color: var(--r-accent-color);
        }

        .run-button:hover:not(:disabled) {
             filter: brightness(90%);
        }

        .run-button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }
        
        .parquet-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9rem;
        }
        .parquet-table th {
            background-color: #f5f5f5;
            padding: 8px 12px;
            text-align: left;
            font-weight: 600;
            border-bottom: 2px solid #ddd;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        .parquet-table td {
            padding: 8px 12px;
            border-bottom: 1px solid #eee;
            white-space: nowrap;
            max-width: 300px;
            overflow: hidden;
            text-overflow: ellipsis;
            height: 36px;
            line-height: 20px;
        }
        .parquet-table tr:hover td {
            background-color: rgba(0, 0, 0, 0.02);
        }
        
        .error {
            color: #e74c3c;
            padding: 12px;
            background-color: #fdf1f0;
            border-left: 4px solid #e74c3c;
            margin: 10px 0;
            border-radius: 0 4px 4px 0;
        }

        /* Log entry styling */
        .log-entry.error { color: #e74c3c; }
        .log-entry.warning { color: #f39c12; }
        .log-entry.success { color: #2ecc71; }
        .log-entry.r { color: #1abc9c; } /* Specific color for R messages */

        @media (max-width: 768px) { 
             .container {
                 grid-template-columns: 1fr;
                 grid-template-rows: auto auto 1fr 1fr; /* Adjusted for smaller screens */
                 grid-template-areas:
                     "left" /* Was left */
                     "right" /* Was right */
                     "terminal" /* Was terminal */
                     ; /* Remove unused areas */
                 height: auto; /* Allow height to adjust */
            }
             .preview-panel {
                min-height: 200px; /* Ensure preview has some height */
            }
             .terminal {
                min-height: 150px; /* Ensure terminal has some height */
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="drop-zone files-drop" id="filesDropZone">
            <div id="filesInstructions">
                <p>Drag & Drop Files or Click Here</p>
                <p class="sub-text">Python (.py), R (.R) scripts and data files (.csv, .parquet, etc.)</p>
            </div>
            <div id="filesList" class="file-list"></div>
        </div>
        
        <div class="preview-panel" id="previewPanel">
            <div class="empty-state">Select a File to Preview</div>
        </div>
        
        <div class="terminal" id="terminal">
            <div class="terminal-header">
                <span>Terminal Output</span>
                <button id="clearTerminal">Clear</button>
            </div>
            <div class="terminal-content" id="terminalContent"></div>
        </div>
    </div>

    <script id="pyodide-webworker" type="text/web-worker">
        // webworker-pyodide.js
        // Uses importScripts, runs as a classic worker
        importScripts("https://cdn.jsdelivr.net/pyodide/v0.27.5/full/pyodide.js");

        let pyodide;
        let pyodideReadyPromise;

        async function loadPyodideAndPackages() {
            if (!pyodide) {
                self.postMessage({ status: 'init', message: 'Loading Pyodide runtime...' });
                pyodide = await loadPyodide();
                self.postMessage({ status: 'init', message: 'Pyodide runtime loaded.' });
            }
            return pyodide;
        }
        
        pyodideReadyPromise = loadPyodideAndPackages(); // Start loading

        self.onmessage = async function(event) {
            const { id, python, files } = event.data;
            
            try {
                self.pyodide = await pyodideReadyPromise;
            } catch (error) {
                 self.postMessage({ id, status: "error", error: `Pyodide initialization failed: ${error.message}` });
                 return;
            }
            
            function sendStatus(status) { self.postMessage({ id, status }); }
            
            let stdout = "";
            let stderr = "";
            const dataDir = '/home/pyodide/data'; // Define dataDir early
            
            try {
                sendStatus("Loading packages (if any)...");
                const importRegex = /^(?:import|from)\s+([a-zA-Z0-9_.]+)/gm;
                let match;
                const packages = new Set();
                while ((match = importRegex.exec(python)) !== null) { packages.add(match[1].split('.')[0]); }
                 if (packages.size > 0) {
                    const nonStdLibPackages = [...packages].filter(p => !['sys', 'os', 'io', 'math', 'random', 'json', 'datetime', 'collections', 're'].includes(p));
                     if (nonStdLibPackages.length > 0) {
                         sendStatus(`Attempting to load packages: ${nonStdLibPackages.join(', ')}`);
                         await self.pyodide.loadPackage(nonStdLibPackages);
                     }
                 }

                sendStatus("Setting up filesystem...");
                self.pyodide.FS.mkdirTree(dataDir); 

                if (files && files.length > 0) {
                    sendStatus(`Loading ${files.length} file(s) into filesystem...`);
                    for (const file of files) {
                         try {
                            self.pyodide.FS.writeFile(`${dataDir}/${file.name}`, new Uint8Array(file.data));
                         } catch (fsError) { sendStatus(`FS Error writing ${file.name}: ${fsError.message}`); console.error(fsError); }
                    }
                }

                sendStatus("Preparing execution environment...");
                self.pyodide.runPython(`
                    import sys, os, io
                    data_dir = '/home/pyodide/data'
                    if os.path.exists(data_dir): os.chdir(data_dir)
                    _stdout_capture = io.StringIO()
                    _stderr_capture = io.StringIO()
                    sys.stdout = _stdout_capture
                    sys.stderr = _stderr_capture
                `);

                sendStatus("Running Python code...");
                let result = null;
                try {
                    result = await self.pyodide.runPythonAsync(python);
                } finally {
                    try {
                        stdout = self.pyodide.runPython("_stdout_capture.getvalue()") || "";
                        stderr = self.pyodide.runPython("_stderr_capture.getvalue()") || "";
                        self.pyodide.runPython("sys.stdout = sys.__stdout__; sys.stderr = sys.__stderr__");
                    } catch (captureError) {
                         console.error("Error capturing/restoring stdio:", captureError);
                         stderr += "\n[Worker: Error capturing/restoring stdio]";
                    }
                }

                sendStatus("Collecting modified files...");
                const modifiedFiles = [];
                try {
                    if (self.pyodide.FS.analyzePath(dataDir).exists) {
                         const dataFiles = self.pyodide.FS.readdir(dataDir);
                         for (const fileName of dataFiles.filter(name => name !== '.' && name !== '..')) {
                             const path = `${dataDir}/${fileName}`;
                             try {
                                 if (self.pyodide.FS.isFile(self.pyodide.FS.stat(path).mode)) {
                                     modifiedFiles.push({ name: fileName, data: self.pyodide.FS.readFile(path, { encoding: 'binary' }) });
                                 }
                             } catch (fileError) { console.error(`Error reading file ${fileName}:`, fileError); }
                         }
                    }
                } catch (fsError) { console.error("Error reading filesystem:", fsError); stderr += `\n[Worker: Error reading filesystem: ${fsError.message}]`; }

                self.postMessage({ id, status: "complete", result: result?.toString(), stdout, stderr, modifiedFiles });
                
            } catch (error) {
                 console.error("Pyodide Worker error:", error);
                 try { // Try to get final stderr
                     if (!stderr && self.pyodide) stderr = self.pyodide.runPython("_stderr_capture.getvalue()") || "";
                     if (self.pyodide) self.pyodide.runPython("sys.stdout = sys.__stdout__; sys.stderr = sys.__stderr__"); // Restore stdio
                 } catch(e) { /* ignore */ }
                 self.postMessage({ id, status: "error", error: error.message || "Unknown error", stderr });
            }
        };
    </script>
    
    <script>
        // --- Global State ---
        const allFiles = [];
        let selectedFile = null;
        const includedForRun = [];
        
        // Persistent workers & message handling
        let pyodideWorker = null;
        const workerPromises = {}; // Store { id: { resolve, reject, workerType } }
        let messageIdCounter = 1;

        // WebR instance (main thread)
        let webRInstance = null;
        let webRInitPromise = null; // To track initialization

        // --- DOM Elements ---
        const filesDropZone = document.getElementById('filesDropZone');
        const filesList = document.getElementById('filesList');
        const previewPanel = document.getElementById('previewPanel');
        const terminalContent = document.getElementById('terminalContent');
        const clearTerminalBtn = document.getElementById('clearTerminal');

        // --- Worker Initialization & Management (Pyodide Only) ---

        function getPyodideWorker() {
            if (!pyodideWorker) {
                log("Initializing Python (Pyodide) worker...");
                try {
                    const workerScript = document.getElementById('pyodide-webworker').textContent;
                    const blob = new Blob([workerScript], { type: 'application/javascript' });
                    const workerUrl = URL.createObjectURL(blob);
                    pyodideWorker = new Worker(workerUrl);

                    pyodideWorker.onmessage = handleWorkerMessage;
                    pyodideWorker.onerror = (event) => handleWorkerError(event, 'python'); // Only Python errors now
                    URL.revokeObjectURL(workerUrl);
                } catch (error) {
                     log(`Failed to create Pyodide worker: ${error.message}`, 'error');
                     console.error("Pyodide Worker Creation Error:", error);
                     pyodideWorker = null;
                }
            }
            return pyodideWorker;
        }

        function handleWorkerError(event, workerType) { // Simplified for Python only
             log(`${workerType.toUpperCase()} Worker Error: ${event.message}`, 'error');
             console.error(`${workerType.toUpperCase()} Worker Error Event:`, event);
             // Reject all pending promises for this worker type
             Object.keys(workerPromises).forEach(id => {
                 if (workerPromises[id]?.workerType === workerType) {
                     workerPromises[id].reject(new Error(`${workerType.toUpperCase()} Worker Error: ${event.message || 'Unknown error'}`));
                     delete workerPromises[id];
                 }
             });
             // Nullify the worker instance
             if (workerType === 'python') pyodideWorker = null;
        }

        // --- Message Handling (Pyodide Only) ---

        function handleWorkerMessage(event) { // Simplified for Python only
            const data = event.data;
            const id = data.id;

            if (data.status === 'init') {
                 log(`Pyodide Worker: ${data.message}`);
                 return;
            }

            const promiseInfo = id ? workerPromises[id] : null;

            if (promiseInfo) {
                const { resolve, reject, workerType } = promiseInfo; // workerType will always be 'python' here

                if (data.status === "complete") {
                    log(`Pyodide execution complete (ID: ${id})`, 'success');
                    if (data.stdout) log(`Stdout:\n${data.stdout}`);
                    if (data.stderr) log(`Stderr:\n${data.stderr}`, data.stderr.trim() ? 'warning' : 'info');
                    if (data.result != null) log(`Result: ${data.result}`);
                    resolve(data);
                    delete workerPromises[id];
                } else if (data.status === "error") {
                    log(`Pyodide Execution Error (ID: ${id}): ${data.error}`, 'error');
                    if (data.stderr) log(`Stderr:\n${data.stderr}`, 'error');
                    reject(new Error(data.error || "Unknown Pyodide worker error"));
                    delete workerPromises[id];
                } else {
                    log(`Pyodide Worker Status (ID: ${id}): ${data.status}`);
                }
            } else if (data.status === "error" && !id) {
                log(`Pyodide Worker Initialization Error: ${data.error}`, 'error');
            } else {
                 console.warn("Received Pyodide worker message with unknown or missing ID:", data);
            }
        }

        function generateId() {
            return messageIdCounter++;
        }

        // Renamed and simplified for Pyodide only
        async function postTaskToPyodideWorker(taskData) {
             const worker = getPyodideWorker();
             if (!worker) {
                 log(`Cannot post task: Pyodide worker is not available.`, 'error');
                 return Promise.reject(new Error(`Pyodide worker not available.`));
             }
            const id = generateId();
            taskData.id = id;

            return new Promise((resolve, reject) => {
                // workerType is implicitly 'python' now
                workerPromises[id] = { resolve, reject, workerType: 'python' };
                 try {
                    worker.postMessage(taskData);
                 } catch (postError) {
                     log(`Error posting message to Pyodide worker: ${postError.message}`, 'error');
                     console.error("Post Message Error:", postError);
                     reject(postError);
                     delete workerPromises[id];
                 }
            });
        }

        // --- WebR Initialization (Main Thread) ---
        async function initializeWebRMain() {
            // Only attempt initialization if it hasn't started or failed previously
            if (!webRInstance && !webRInitPromise) {
                log("Initializing R (WebR) in main thread...");
                webRInitPromise = import('https://webr.r-wasm.org/latest/webr.mjs')
                    .then(async ({ WebR }) => {
                        try {
                            const webR = new WebR({ /* Optional config */ });
                            log("WebR Class loaded. Initializing runtime...");
                            await webR.init();
                            webRInstance = webR; // Assign to global instance
                            log("WebR runtime initialized successfully.", 'success');
                            return webRInstance; // Resolve the promise with the instance
                        } catch (error) {
                            log(`WebR Initialization failed: ${error.message}`, 'error');
                            console.error("WebR Initialization Error:", error);
                            webRInitPromise = null; // Reset promise to allow retry on next call
                            throw error; // Propagate error
                        }
                    })
                    .catch(error => {
                        log(`Failed to load WebR module: ${error.message}`, 'error');
                        console.error("WebR Module Load Error:", error);
                        webRInitPromise = null; // Reset promise
                        throw error; // Propagate error
                    });
            }
            // Return the promise that resolves with the instance
            return webRInitPromise;
        }

        // --- Logging ---
        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logElement = document.createElement('div');
            const safeMessage = message.toString().replace(/</g, "&lt;").replace(/>/g, "&gt;");
            logElement.innerHTML = `[${timestamp}] ${safeMessage}`;
            logElement.classList.add('log-entry', type);
            terminalContent.appendChild(logElement);
            terminalContent.scrollTop = terminalContent.scrollHeight;
        }

        clearTerminalBtn?.addEventListener('click', () => {
            if (terminalContent) terminalContent.innerHTML = '';
            log('Terminal cleared');
        });

        // --- Core Execution Logic ---

        async function runPythonScript(scriptContent, additionalFiles = []) {
            const worker = getPyodideWorker();
            if (!worker) return Promise.reject("Pyodide worker failed to initialize.");

            log(`Sending Python task to worker...`);
            const fileData = await Promise.all(additionalFiles.map(async (file) => ({
                name: file.name, data: await file.arrayBuffer()
            })));
            return postTaskToPyodideWorker({ python: scriptContent, files: fileData });
        }

        // Rewritten runRScript to use WebR's native message handling
        async function runRScript(scriptContent, additionalFiles = []) {
            log(`Attempting to run R script...`, 'r');

            if (!webRInstance) {
                log("WebR not initialized. Attempting initialization...", 'r');
                try {
                    await initializeWebRMain();
                    if (!webRInstance) throw new Error("WebR initialization failed after attempt.");
                } catch (initError) {
                    log(`Cannot run R script, initialization failed: ${initError.message}`, 'error');
                    throw initError;
                }
            }

            const currentWebR = webRInstance;
            let stdout = "";
            let stderr = "";
            const dataDir = '/home/webR/data';
            
            try {
                log("Setting up R filesystem...", 'r');
                // Create data directory and set working directory
                await currentWebR.evalRVoid(`dir.create("${dataDir}", recursive = TRUE, showWarnings = FALSE)`);
                await currentWebR.evalRVoid(`setwd("${dataDir}")`);

                // Load additional files into filesystem
                if (additionalFiles && additionalFiles.length > 0) {
                    log(`Loading ${additionalFiles.length} file(s) into R filesystem...`, 'r');
                    for (const file of additionalFiles) {
                        try {
                            const data = await file.arrayBuffer();
                            await currentWebR.FS.writeFile(`${dataDir}/${file.name}`, new Uint8Array(data));
                        } catch (fsError) {
                            log(`FS Error writing ${file.name}: ${fsError.message}`, 'warning');
                            console.error(fsError);
                        }
                    }
                }

                log("Executing R code...", 'r');
                
                // Set up a message queue to capture output
                // We'll use WebR's message passing system to get stdout/stderr
                const messageQueue = [];
                
                // Start a task to read messages
                const messageReader = (async () => {
                    try {
                        for (;;) {
                            const message = await currentWebR.read();
                            messageQueue.push(message);
                            
                            // If we receive a closed message, break the loop
                            if (message.type === 'closed') break;
                        }
                    } catch (error) {
                        console.error("Error reading WebR messages:", error);
                    }
                })();
                
                // Execute the R code
                let resultObj = null;
                try {
                    // Write the script to execute it
                    resultObj = await currentWebR.evalR(scriptContent);
                } finally {
                    // Stop the message reader with a small delay to ensure all messages are captured
                    await new Promise(resolve => setTimeout(resolve, 100));
                    
                    // Process the captured output messages
                    for (const message of messageQueue) {
                        if (message.type === 'stdout') {
                            stdout += message.data + '\n';
                        } else if (message.type === 'stderr') {
                            stderr += message.data + '\n';
                        }
                    }
                    
                    // Trim trailing newlines
                    stdout = stdout.trim();
                    stderr = stderr.trim();
                }

                log("R code execution finished. Processing results...", 'r');

                // Convert the result to string if available
                let resultString = null;
                if (resultObj && resultObj.type !== 'null') {
                    try {
                        resultString = await resultObj.toString();
                    } catch (resultError) {
                        log(`Error converting R result to string: ${resultError.message}`, 'warning');
                        stderr += (stderr ? '\n' : '') + `[MainThread: Error converting R result: ${resultError.message}]`;
                    }
                }

                log("Collecting modified files from R filesystem...", 'r');
                const modifiedFiles = [];
                try {
                    const listFilesCmd = `list.files(path='${dataDir}', recursive=FALSE)`;
                    const dataFilesRObject = await currentWebR.evalR(listFilesCmd);
                    const dataFiles = await dataFilesRObject.toArray();

                    for (const fileName of dataFiles.filter(name => name !== '.' && name !== '..')) {
                        const path = `${dataDir}/${fileName}`;
                        try {
                            const isDirectory = await currentWebR.evalRBoolean(`dir.exists('${path}')`);
                            if (!isDirectory) {
                                const fileData = await currentWebR.FS.readFile(path, { encoding: 'binary' });
                                modifiedFiles.push({ name: fileName, data: fileData });
                            }
                        } catch (fileError) {
                            log(`Error reading back file ${fileName}: ${fileError.message}`, 'warning');
                            stderr += (stderr ? '\n' : '') + `[MainThread: Error reading file ${fileName}: ${fileError.message}]`;
                        }
                    }
                } catch (fsError) {
                    log(`Error listing files in ${dataDir}: ${fsError.message}`, 'warning');
                    stderr += (stderr ? '\n' : '') + `[MainThread: Error listing files: ${fsError.message}]`;
                }

                // Log the outputs
                if (stdout) log(`R Stdout:\n${stdout}`, 'r');
                if (stderr) log(`R Stderr:\n${stderr}`, stderr.trim() ? 'warning' : 'info');
                if (resultString != null) log(`R Result: ${resultString}`);

                return {
                    status: "complete",
                    result: resultString,
                    stdout: stdout,
                    stderr: stderr,
                    modifiedFiles: modifiedFiles
                };

            } catch (error) {
                log(`R Execution Error: ${error.message}`, 'error');
                console.error("WebR Execution Error:", error);
                stderr += (stderr ? '\n' : '') + `[MainThread: Execution failed: ${error.message}]`;
                throw new Error(`R Execution Failed: ${error.message || 'Unknown error'}`);
            }
        }

        // --- File Handling & UI ---

        function handleFileSelect(files) {
            let filesAdded = false;
            Array.from(files).forEach(file => {
                if (!allFiles.some(f => f.name === file.name)) {
                    const fileObj = file;
                    const nameLower = file.name.toLowerCase();
                    fileObj.isPython = nameLower.endsWith('.py');
                    fileObj.isR = nameLower.endsWith('.r'); 
                    fileObj.isData = !fileObj.isPython && !fileObj.isR; // Simple data file flag
                    
                    allFiles.push(fileObj);
                    log(`Added file: ${file.name} ${fileObj.isPython ? '(Python)' : ''}${fileObj.isR ? '(R)' : ''}${fileObj.isData ? '(Data)' : ''}`);
                    filesAdded = true;
                } else {
                    log(`File ${file.name} already exists, skipping.`, 'warning');
                }
            });
            if (filesAdded) updateFileList();
        }
        
        function getFileIcon(file) {
            if (file.isPython) return '<span class="file-icon python">🐍</span>';
            if (file.isR) return '<span class="file-icon r">🇷</span>'; 
            const ext = file.name.split('.').pop().toLowerCase();
            if (['csv', 'tsv', 'txt'].includes(ext)) return '<span class="file-icon data">📄</span>'; 
            if (['parquet', 'json', 'xml', 'yaml', 'yml'].includes(ext)) return '<span class="file-icon data">📦</span>'; 
            if (['png', 'jpg', 'jpeg', 'gif', 'svg', 'webp'].includes(ext)) return '<span class="file-icon data">🖼️</span>'; 
            return '<span class="file-icon">❓</span>';
        }

        function updateFileList() {
            const instructionsElement = document.getElementById('filesInstructions');
            if (instructionsElement) instructionsElement.style.display = allFiles.length > 0 ? 'none' : 'flex';
            
            if (!filesList) return;
            filesList.innerHTML = '';
            
            if (allFiles.length > 0) {
                const actionButtonsHTML = `
                    <div class="action-buttons">
                        <button id="runSelectedFiles" class="btn btn-run" disabled>Run</button>
                        <button id="includeInRunFiles" class="btn btn-include" disabled>Include in Run</button>
                        <button id="downloadSelectedFiles" class="btn btn-download" disabled>Download</button>
                        <button id="removeSelectedFiles" class="btn btn-remove" disabled>Delete</button>
                    </div>`;
                filesList.insertAdjacentHTML('beforeend', actionButtonsHTML);

                const tableHTML = `
                    <table class="file-table">
                        <thead>
                            <tr>
                                <th><input type="checkbox" id="selectAllFiles"></th>
                                <th class="sortable sort-active sort-asc" data-sort="name">Name</th>
                                <th class="sortable" data-sort="size">Size</th>
                                <th class="sortable" data-sort="date">Last Modified</th>
                            </tr>
                        </thead>
                        <tbody></tbody>
                    </table>`;
                filesList.insertAdjacentHTML('beforeend', tableHTML);
                const tbody = filesList.querySelector('tbody');
                
                allFiles.forEach(file => {
                    const tr = document.createElement('tr');
                    tr.className = `file-row ${file.isR ? 'is-r' : ''}`; 
                    const date = new Date(file.lastModified);
                    const dateString = date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                    const sizeString = file.size < 1024 ? `${file.size} B` :
                                     file.size < 1024 * 1024 ? `${(file.size / 1024).toFixed(1)} KB` :
                                     `${(file.size / (1024 * 1024)).toFixed(1)} MB`;
                    
                    let nameCellHTML = `${getFileIcon(file)}${file.name}`;
                    if (includedForRun.some(f => f.name === file.name)) {
                         nameCellHTML += ' <span class="included-badge">included</span>';
                    }

                    tr.innerHTML = `
                        <td><input type="checkbox" class="file-checkbox" data-filename="${file.name}"></td>
                        <td data-value="${file.name.toLowerCase()}">${nameCellHTML}</td>
                        <td data-value="${file.size}">${sizeString}</td>
                        <td data-value="${file.lastModified}">${dateString}</td>
                    `;
                    tr.dataset.name = file.name.toLowerCase();
                    tr.dataset.size = String(file.size);
                    tr.dataset.date = String(file.lastModified);
                    
                    tr.addEventListener('click', (e) => {
                        if (e.target.type !== 'checkbox' && !e.target.closest('button')) {
                            selectFile(file);
                        }
                    });
                    tbody?.appendChild(tr);
                });

                filesList.addEventListener('change', (e) => {
                    if (e.target.matches('#selectAllFiles')) {
                         filesList.querySelectorAll('.file-checkbox').forEach(cb => cb.checked = e.target.checked);
                         updateActionButtonsState();
                    } else if (e.target.matches('.file-checkbox')) {
                         updateActionButtonsState();
                    }
                });

                filesList.addEventListener('click', (e) => {
                    if (e.target.matches('#runSelectedFiles')) runSelected();
                    else if (e.target.matches('#includeInRunFiles')) includeSelected();
                    else if (e.target.matches('#downloadSelectedFiles')) downloadSelected();
                    else if (e.target.matches('#removeSelectedFiles')) removeSelected();
                    else if (e.target.matches('.sortable')) handleSort(e.target);
                });
                
            } else {
                 if(selectedFile) clearPreview();
            }
             updateActionButtonsState();
        }
        
        function handleSort(header) {
            const tbody = filesList?.querySelector('tbody');
            if (!tbody || !header) return;

             const sortBy = header.dataset.sort;
             const currentIsAsc = header.classList.contains('sort-asc');
             const isAsc = !currentIsAsc; 

             filesList.querySelectorAll('.sortable').forEach(h => h.classList.remove('sort-active', 'sort-asc', 'sort-desc'));
             header.classList.add('sort-active', isAsc ? 'sort-asc' : 'sort-desc');

             const rows = Array.from(tbody.querySelectorAll('tr'));
             rows.sort((a, b) => {
                 let aValue = a.dataset[sortBy];
                 let bValue = b.dataset[sortBy];
                 if (sortBy === 'size' || sortBy === 'date') { aValue = Number(aValue); bValue = Number(bValue); }
                 if (aValue < bValue) return isAsc ? -1 : 1;
                 if (aValue > bValue) return isAsc ? 1 : -1;
                 return 0;
             });
             rows.forEach(row => tbody.appendChild(row));
        }

        function getSelectedFiles() {
            const selectedFilenames = Array.from(filesList?.querySelectorAll('.file-checkbox:checked') || [])
                                         .map(cb => cb.dataset.filename);
            return allFiles.filter(f => selectedFilenames.includes(f.name));
        }

        function updateActionButtonsState() {
            const runButton = document.getElementById('runSelectedFiles');
            const includeButton = document.getElementById('includeInRunFiles');
            const downloadButton = document.getElementById('downloadSelectedFiles');
            const removeButton = document.getElementById('removeSelectedFiles');
            
            if (!runButton) return;

            const selected = getSelectedFiles();
            const hasSelection = selected.length > 0;
            
            includeButton.disabled = !hasSelection;
            downloadButton.disabled = !hasSelection;
            removeButton.disabled = !hasSelection;

            const selectedScripts = selected.filter(f => f.isPython || f.isR);
            const hasPython = selectedScripts.some(f => f.isPython);
            const hasR = selectedScripts.some(f => f.isR);
            const canRun = selectedScripts.length > 0 && !(hasPython && hasR); 

            runButton.disabled = !canRun;
            runButton.classList.remove('run-r'); 
            if (canRun) {
                runButton.textContent = hasPython ? 'Run Python' : 'Run R';
                 if (hasR) runButton.classList.add('run-r'); 
            } else {
                 runButton.textContent = 'Run'; 
            }
        }

        async function runSelected() {
             const selectedScripts = getSelectedFiles().filter(f => f.isPython || f.isR);
             if (selectedScripts.length === 0) return;

             const isPythonRun = selectedScripts[0].isPython;
             const runner = isPythonRun ? executePythonFile : executeRFile;
             const type = isPythonRun ? 'Python' : 'R';

             log(`Executing ${selectedScripts.length} ${type} script(s)...`);
             for (const file of selectedScripts) {
                 await runner(file).catch(err => log(`Execution failed for ${file.name}: ${err.message}`, 'error')); 
             }
             log(`${type} execution task(s) finished.`);
        }

        function includeSelected() {
             const selected = getSelectedFiles();
             let includedNew = false;
             selected.forEach(file => {
                 if (!includedForRun.some(f => f.name === file.name)) {
                     includedForRun.push(file);
                     log(`Included file for subsequent runs: ${file.name}`, 'success');
                     includedNew = true;
                 } else {
                      log(`File ${file.name} was already included.`, 'info');
                 }
             });
             if (includedNew) {
                  filesList?.querySelectorAll('.file-checkbox:checked').forEach(cb => cb.checked = false);
                  const selectAll = document.getElementById('selectAllFiles');
                  if (selectAll) selectAll.checked = false;
                  updateFileList();
             }
        }
        
        function downloadSelected() {
             const selected = getSelectedFiles();
             if (selected.length === 0) return;

             const downloadFile = (blob, filename) => {
                 const url = URL.createObjectURL(blob);
                 const a = document.createElement('a');
                 a.href = url; a.download = filename; a.click(); 
                 setTimeout(() => URL.revokeObjectURL(url), 100);
                 log(`Downloaded: ${filename}`, 'success');
             };

             if (selected.length === 1) {
                 downloadFile(selected[0], selected[0].name);
             } else {
                 log('Loading JSZip to archive multiple files...');
                 const script = document.createElement('script');
                 script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
                 script.onload = async () => {
                     try {
                         const zip = new JSZip();
                         selected.forEach(file => zip.file(file.name, file));
                         const content = await zip.generateAsync({ type: 'blob' });
                         downloadFile(content, 'files.zip');
                     } catch (error) { log(`Error creating zip file: ${error.message}`, 'error'); }
                 };
                 script.onerror = () => log('Failed to load JSZip library.', 'error');
                 document.head.appendChild(script);
                 script.remove();
             }
        }

        function removeSelected() {
             const selectedNames = getSelectedFiles().map(f => f.name);
             if (selectedNames.length === 0) return;

             let fileRemoved = false;
             for (let i = allFiles.length - 1; i >= 0; i--) {
                 if (selectedNames.includes(allFiles[i].name)) {
                     log(`Deleted file: ${allFiles[i].name}`, 'warning');
                     allFiles.splice(i, 1);
                     fileRemoved = true;
                 }
             }
             for (let i = includedForRun.length - 1; i >= 0; i--) {
                 if (selectedNames.includes(includedForRun[i].name)) {
                     includedForRun.splice(i, 1);
                 }
             }

             if (fileRemoved) {
                 if (selectedFile && selectedNames.includes(selectedFile.file.name)) clearPreview();
                 updateFileList(); 
             }
        }
        
         function handleModifiedFiles(modifiedFiles) {
             if (!modifiedFiles || modifiedFiles.length === 0) return;
            log(`Processing ${modifiedFiles.length} modified/new files from execution...`, 'info');

            let fileListChanged = false;
            modifiedFiles.forEach(modFile => {
                 const blob = new Blob([modFile.data], { type: modFile.type || 'application/octet-stream' }); 
                 const file = new File([blob], modFile.name, { lastModified: Date.now() });
                 const nameLower = file.name.toLowerCase();
                 file.isPython = nameLower.endsWith('.py');
                 file.isR = nameLower.endsWith('.r');
                 file.isData = !file.isPython && !file.isR;

                 const existingIndex = allFiles.findIndex(f => f.name === file.name);
                 if (existingIndex !== -1) {
                     allFiles[existingIndex] = file; 
                     log(`Updated file: ${file.name}`, 'success');
                 } else {
                     allFiles.push(file); 
                     log(`Added new file: ${file.name}`, 'success');
                 }
                 fileListChanged = true;
            });

            if (fileListChanged) {
                 updateFileList(); 
                 if (selectedFile && modifiedFiles.some(mf => mf.name === selectedFile.file.name)) {
                     const updatedFile = allFiles.find(f => f.name === selectedFile.file.name);
                     if (updatedFile) {
                         selectFile(updatedFile);
                         log(`Refreshed preview for updated file: ${updatedFile.name}`);
                     }
                 }
            }
         }

        async function executePythonFile(file) {
            log(`Executing Python file: ${file.name}...`);
            const content = await file.text();
            const dataFiles = [...includedForRun];
            getSelectedFiles().forEach(selected => {
                if (selected.isData && !dataFiles.some(df => df.name === selected.name)) {
                    dataFiles.push(selected);
                }
            });
            if (dataFiles.length > 0) log(`Including ${dataFiles.length} data file(s) for Python run.`);

            try {
                const result = await runPythonScript(content, dataFiles);
                if (result.modifiedFiles?.length > 0) handleModifiedFiles(result.modifiedFiles);
                log(`Python execution successful for ${file.name}.`, 'success');
            } catch (error) {
                log(`Failed Python execution task for ${file.name}. See previous errors.`, 'error');
            }
        }

        async function executeRFile(file) {
            log(`Executing R file: ${file.name}...`, 'r');
            const content = await file.text();
            const dataFiles = [...includedForRun];
            getSelectedFiles().forEach(selected => {
                if (selected.isData && !dataFiles.some(df => df.name === selected.name)) {
                    dataFiles.push(selected);
                }
            });
            if (dataFiles.length > 0) log(`Including ${dataFiles.length} data file(s) for R run.`, 'r');

            try {
                const result = await runRScript(content, dataFiles);
                if (result.modifiedFiles?.length > 0) handleModifiedFiles(result.modifiedFiles);
                log(`R execution successful for ${file.name}.`, 'success');
            } catch (error) {
                log(`Failed R execution task for ${file.name}. See previous errors.`, 'error');
            }
        }

        // --- File Preview ---
        function selectFile(file) {
            selectedFile = { file }; 
            document.querySelectorAll('.file-row').forEach(row => {
                 const nameCell = row.querySelector('td:nth-child(2)');
                 row.classList.toggle('active', nameCell && nameCell.textContent.includes(file.name));
            });
            previewFile(file);
        }
        
        function clearPreview() {
             if (previewPanel) previewPanel.innerHTML = '<div class="empty-state">Select a File to Preview</div>';
             selectedFile = null;
        }

        async function previewParquetFile(file) {
            log(`Loading parquet preview for ${file.name}...`);
            if (!previewPanel) return;
            previewPanel.innerHTML = `<div>Loading parquet file: ${file.name}...</div>`; 
            
            try {
                 const { parquetReadObjects, parquetMetadataAsync, parquetSchema } = 
                    await import('https://cdn.jsdelivr.net/npm/hyparquet/src/hyparquet.min.js');

                 const buffer = await file.arrayBuffer();
                 const metadata = await parquetMetadataAsync(buffer);
                 const schema = parquetSchema(metadata);
                 const numRows = Number(metadata.num_rows);
                 const columnNames = schema.children.map(c => c.element.name);
                 const previewRowCount = Math.min(100, numRows);
                 const data = await parquetReadObjects({ file: buffer, columns: columnNames, rowStart: 0, rowEnd: previewRowCount });

                 let tableHTML = `<div style="overflow: auto; max-height: 400px;"><table class="parquet-table"><thead><tr>${columnNames.map(col => `<th>${col}</th>`).join('')}</tr></thead><tbody>`;
                 data.forEach(row => { tableHTML += `<tr>${columnNames.map(col => `<td>${row[col] ?? 'null'}</td>`).join('')}</tr>`; });
                 tableHTML += `</tbody></table></div>`;

                 const schemaInfo = columnNames.map(name => { const child = schema.children.find(c => c.element.name === name); return `${name}: ${child?.element?.type ?? 'unknown'}`; }).join('<br>');
                 let infoHTML = `<div style="margin-top: 15px; font-size: 0.9rem; color: #666;"><div><strong>Rows:</strong> ${numRows} | <strong>Columns:</strong> ${columnNames.length} | <strong>Preview:</strong> ${previewRowCount} rows</div><div style="margin-top: 10px;"><strong>Schema:</strong><pre style="font-size: 0.8rem;">${schemaInfo}</pre></div></div>`;
                 
                 previewPanel.innerHTML = tableHTML + infoHTML;
                 log(`Parquet preview loaded: ${file.name}`, 'success');

            } catch (error) {
                 previewPanel.innerHTML = `<div class="error">Error reading parquet file: ${error.message}</div>`;
                 log(`Error reading parquet file ${file.name}: ${error.message}`, 'error'); console.error(error);
            }
        }
        
        function previewHtmlFile(content) {
            if (!previewPanel) return;
             const iframeContainer = document.createElement('div');
             iframeContainer.style.cssText = 'width: 100%; height: 500px; border: 1px solid #ddd; border-radius: 4px; overflow: hidden;';
             const iframe = document.createElement('iframe');
             iframe.style.cssText = 'width: 100%; height: 100%; border: none;';
             iframe.sandbox = 'allow-scripts allow-same-origin'; 
             iframeContainer.appendChild(iframe);
             previewPanel.appendChild(iframeContainer);
             
             if ('srcdoc' in iframe) iframe.srcdoc = content;
             else { iframe.contentWindow.document.open(); iframe.contentWindow.document.write(content); iframe.contentWindow.document.close(); }
        }
        
        function previewFile(file) {
            if (!previewPanel) return;
             previewPanel.innerHTML = '';

            const header = document.createElement('div');
            header.style.cssText = 'padding-bottom: 15px; border-bottom: 1px solid #eee; margin-bottom: 15px; display: flex; justify-content: space-between; align-items: center;';
            header.innerHTML = `<strong>${file.name}</strong> (${(file.size / 1024).toFixed(1)} KB)`;
            
            if (file.isPython || file.isR) {
                const runButton = document.createElement('button');
                runButton.textContent = `Run ${file.isPython ? 'Python' : 'R'} Script`;
                runButton.className = `run-button ${file.isR ? 'run-r' : ''}`; 
                runButton.addEventListener('click', (e) => { 
                    e.stopPropagation();
                    if (file.isPython) executePythonFile(file); else if (file.isR) executeRFile(file); 
                });
                header.appendChild(runButton);
            }
            previewPanel.appendChild(header);

            const ext = file.name.split('.').pop().toLowerCase();
            const reader = new FileReader();

            reader.onload = (e) => {
                const content = e.target.result;
                 if (ext === 'html') previewHtmlFile(content);
                 else if (['py', 'r', 'txt', 'json', 'csv', 'log', 'md', 'yaml', 'yml', 'sql'].includes(ext) || file.type.startsWith('text/')) {
                     const codePreview = document.createElement('pre');
                     codePreview.className = 'code-preview';
                     codePreview.textContent = content; 
                     previewPanel.appendChild(codePreview);
                 } else {
                     previewPanel.innerHTML += `<div class="error">Cannot display binary file content.</div>`;
                 }
            };
            reader.onerror = () => {
                previewPanel.innerHTML += '<div class="error">Error reading file for preview.</div>';
                log(`Error reading file ${file.name} for preview`, 'error');
            };

            if (ext === 'parquet') previewParquetFile(file);
            else if (file.type.startsWith('image/')) {
                 const img = document.createElement('img');
                 img.src = URL.createObjectURL(file);
                 img.style.cssText = 'max-width: 100%; max-height: 400px; display: block; margin-top: 10px;';
                 img.onload = () => URL.revokeObjectURL(img.src); 
                 previewPanel.appendChild(img);
                 log(`Previewing image: ${file.name}`);
            } else if (file.size > 5 * 1024 * 1024) {
                 previewPanel.innerHTML += `<div class="warning">File is large (${(file.size / (1024*1024)).toFixed(1)} MB). Text preview skipped.</div>`;
                 log(`Skipping text preview for large file: ${file.name}`, 'warning');
            } else if (['py', 'r', 'txt', 'json', 'csv', 'log', 'md', 'yaml', 'yml', 'sql'].includes(ext) || file.type.startsWith('text/')) {
                 reader.readAsText(file);
            } else {
                 previewPanel.innerHTML += '<div>No preview available for this file type.</div>';
                 log(`No preview available for: ${file.name} (${file.type || ext})`);
            }
        }

        // --- Drag and Drop & Click to Upload Setup ---
        function setupDropZone(dropZone) {
            if (!dropZone) return;
            
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, (e) => { e.preventDefault(); e.stopPropagation(); }, false);
            });

            ['dragenter', 'dragover'].forEach(eventName => {
                dropZone.addEventListener(eventName, () => dropZone.classList.add('active'), false);
            });

            ['dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, () => dropZone.classList.remove('active'), false);
            });
            
            dropZone.addEventListener('drop', (e) => {
                handleFileSelect(e.dataTransfer.files);
            }, false);

            dropZone.addEventListener('click', (e) => {
                 if (e.target.closest('#filesInstructions') || e.target === dropZone) {
                     const fileInput = document.createElement('input');
                     fileInput.type = 'file';
                     fileInput.multiple = true;
                     fileInput.style.display = 'none';
                     fileInput.onchange = (ev) => handleFileSelect(ev.target.files);
                     document.body.appendChild(fileInput);
                     fileInput.click();
                     document.body.removeChild(fileInput);
                 }
            });
        }

        // --- Initialization ---
        function init() {
             if (document.readyState === 'loading') {
                 document.addEventListener('DOMContentLoaded', runInit);
             } else {
                 runInit();
             }
        }
        
        function runInit() {
             setupDropZone(filesDropZone);
             log('App initialized. Ready for Python (.py) and R (.R) files.');
             initializeWebRMain().catch(err => {
                 console.error("Initial WebR setup failed on load:", err);
                 log("WebR initialization failed on startup. Will retry on first R execution.", "warning");
             });
        }

        init();
    </script>
</body>
</html>